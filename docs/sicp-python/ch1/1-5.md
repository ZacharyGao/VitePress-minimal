# 1.5 控制

:::info
译者：[Mancuoj](https://github.com/mancuoj)

协议：[CC BY-NC-SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/)

来源：[1.5 Control](http://composingprograms.com/pages/15-control.html)
:::

我们现在可以定义的函数的能力十分有限，因为我们还没有引入一种方法来进行比较，并根据比较的结果执行不同的操作。控制语句将赋予我们这种能力，就是根据逻辑比较的结果来控制程序执行流程的语句。

语句与我们目前研究过的表达式有着根本的不同，它们没有值。执行一个控制语句决定了解释器接下来应该做什么，而不是计算某些东西。

## 1.5.1 语句

到目前为止，我们虽然主要思考的是如何计算求解表达式，但我们已经见过了三种语句：赋值（assignment）、 `def` 和 `return` 语句。尽管这些 Python 代码都包含表达式作为它们的一部分，但它们本身并不是表达式。

语句不会被求解，而会被执行。每个语句都描述了对解释器状态的一些更改，并且执行语句就会应用该更改。正如我们在 `return` 和赋值语句中看到的那样，执行语句可能涉及求解其包含的子表达式。

表达式也可以作为语句执行，在这种情况下，它们会被求值，但它们的值会被丢弃。执行纯函数没有效果，但执行非纯函数会因为调用函数而产生效果。

思考一下，例如：

```py
>>> def square(x):
        mul(x, x) # 小心！此调用不返回值。
```

这个例子是有效的 Python 代码，但可能不能达到预期。函数体由一个表达式组成。表达式本身是一个有效的语句，但语句的效果是调用 `mul` 函数，然后把结果丢弃。如果你想对表达式的结果做些什么，你需要这样做：用赋值语句存储它或用 `return` 语句返回它：

```py
>>> def square(x):
        return mul(x, x)
```

有时，在调用 `print` 等非纯函数时，拥有一个主体为表达式的函数确实有意义。

```py
>>> def print_square(x):
        print(square(x))
```

在最高层级上，Python 解释器的工作是执行由语句组成的程序。然而，很多有趣的计算工作都来自对表达式的求值。语句用来管理程序中不同表达式之间的关系，以及它们产生的结果。

## 1.5.2 复合语句

通常，Python 代码是一系列语句。简单语句是不以冒号结尾的单行，而由其他语句（简单语句和复合语句）组成被称为复合语句。复合语句通常跨越多行，以单行标题（header）开始，并以冒号结尾，冒号标识语句的类型。标题和缩进的代码组（suite）一起称为子句。复合语句由一个或多个子句组成：

```py
<header>:
    <statement>
    <statement>
    ...
<separating header>:
    <statement>
    <statement>
    ...
...
```

我们可以用这些术语来理解我们之前介绍过的语句。

-  表达式、返回语句和赋值语句都是简单语句。
-  `def` 语句是复合语句，`def` 头后面的代码组定义了函数体。

对每类 header 有专门的求值规则来规定，何时执行以及是否执行其代码组中的语句。我们说“the header controls its suite”，例如，在 `def` 语句中，`return` 表达式不会立即求值，而是存储起来供以后调用该函数时使用。

我们现在也可以理解多行程序了。

- 要执行一系列语句，会先执行第一个语句。如果该语句不重定向控制，则继续执行语句序列的其余部分（如果还有的话）。

这个定义揭示了递归定义序列（sequence）的基本结构：一个序列可以分解成它的第一个元素和其余元素。语句序列的“其余部分”本身就是语句序列！因此，我们可以递归地应用这个执行规则。这种将序列视为递归的数据结构的观点将在后面的章节中再次出现。

此规则的重要结果是语句按顺序执行，但由于重定向控制（redirected control），后面的语句可能永远不会被执行到。

实践指南：缩进代码组时，所有行必须以相同的方式缩进相同的量（使用空格，而不是制表符）。缩进的任何变化都会导致错误。

## 1.5.3 定义函数 II：局部赋值

最初，我们声明用户定义函数的主体仅由包含单个返回表达式的 `return` 语句组成。事实上，函数可以定义超出单个表达式的一系列操作。

每当用户定义的函数被调用时，其代码组中的子句序列将会在局部环境中执行 --> 该环境通过调用函数创建的局部帧开始。`return` 语句会重定向控制：每当执行一个 `return` 语句时，函数应用程序就会终止，`return` 表达式的值会作为被调用函数的返回值。

赋值语句可以出现在函数体内。例如，以下函数使用了两步计算，首先计算两个数的绝对值的差，然后求出它与第一个数的百分比值并返回：

<iframe width="100%" height="500" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20percent_difference%28x,%20y%29%3A%0A%20%20%20%20difference%20%3D%20abs%28x-y%29%0A%20%20%20%20return%20100%20*%20difference%20/%20x%0Aresult%20%3D%20percent_difference%2840,%2050%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

赋值语句的作用是将名称与当前环境中的第一帧的值绑定。因此，函数体内的赋值语句不会影响全局帧。“函数只能操纵其局部帧”是创建模块化程序的关键，而在模块化程序中，纯函数仅通过它们接收和返回的值与外界交互。

当然， `percent_difference` 函数可以写成单个表达式，如下所示，但返回表达式会更复杂。

```py
>>> def percent_difference(x, y):
        return 100 * abs(x-y) / x
>>> percent_difference(40, 50)
25.0
```

到目前为止，局部赋值并没有增强函数定义的表达能力，而当它与其他控制语句结合时，就会增强。此外，局部赋值在“通过为中间量赋名来解释复杂表达式的含义”方面也起着至关重要的作用。

## 1.5.4 条件语句

Python has a built-in function for computing absolute values.

```py
>>> abs(-2)
2
```

We would like to be able to implement such a function ourselves, but we have no obvious way to define a function that has a comparison and a choice. We would like to express that if x is positive, abs(x) returns x. Furthermore, if x is 0, abs(x) returns 0. Otherwise, abs(x) returns -x. In Python, we can express this choice with a conditional statement.

<iframe width="100%" height="550" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20absolute_value%28x%29%3A%0A%20%20%20%20%22%22%22Compute%20abs%28x%29.%22%22%22%0A%20%20%20%20if%20x%20%3E%200%3A%0A%20%20%20%20%20%20%20%20return%20x%0A%20%20%20%20elif%20x%20%3D%3D%200%3A%0A%20%20%20%20%20%20%20%20return%200%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20-x%0A%0Aresult%20%3D%20absolute_value%28-2%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>


This implementation of absolute_value raises several important issues:

**Conditional statements**. A conditional statement in Python consists of a series of headers and suites: a required if clause, an optional sequence of elif clauses, and finally an optional else clause:

```py
if <expression>:
    <suite>
elif <expression>:
    <suite>
else:
    <suite>
```

When executing a conditional statement, each clause is considered in order. The computational process of executing a conditional clause follows.

1.  Evaluate the header's expression.
2.  If it is a true value, execute the suite. Then, skip over all subsequent clauses in the conditional statement.

If the else clause is reached (which only happens if all if and elif expressions evaluate to false values), its suite is executed.

**Boolean contexts**. Above, the execution procedures mention "a false value" and "a true value." The expressions inside the header statements of conditional blocks are said to be in _boolean contexts_: their truth values matter to control flow, but otherwise their values are not assigned or returned. Python includes several false values, including 0, None, and the _boolean_ value False. All other numbers are true values. In Chapter 2, we will see that every built-in kind of data in Python has both true and false values.

**Boolean values**. Python has two boolean values, called True and False. Boolean values represent truth values in logical expressions. The built-in comparison operations, `>, <, >=, <=, ==, !=`, return these values.

```py
>>> 4 < 2
False
>>> 5 >= 5
True
```

This second example reads "5 is greater than or equal to 5", and corresponds to the function ge in the operator module.

```py
>>> 0 == -0
True
```

This final example reads "0 equals -0", and corresponds to eq in the operator module. Notice that Python distinguishes assignment (=) from equality comparison (==), a convention shared across many programming languages.

**Boolean operators**. Three basic logical operators are also built into Python:

```py
>>> True and False
False
>>> True or False
True
>>> not False
True
```

Logical expressions have corresponding evaluation procedures. These procedures exploit the fact that the truth value of a logical expression can sometimes be determined without evaluating all of its subexpressions, a feature called _short-circuiting_.

To evaluate the expression `<left>` and `<right>`:

1.  Evaluate the subexpression `<left>`.
2.  If the result is a false value v, then the expression evaluates to v.
3.  Otherwise, the expression evaluates to the value of the subexpression `<right>`.

To evaluate the expression `<left>` or `<right>`:

1.  Evaluate the subexpression `<left>`.
2.  If the result is a true value v, then the expression evaluates to v.
3.  Otherwise, the expression evaluates to the value of the subexpression `<right>`.

To evaluate the expression not `<exp>`:

1.  Evaluate `<exp>`; The value is True if the result is a false value, and False otherwise.

These values, rules, and operators provide us with a way to combine the results of comparisons. Functions that perform comparisons and return boolean values typically begin with is, not followed by an underscore (e.g., isfinite, isdigit, isinstance, etc.).

## 1.5.5 迭代

In addition to selecting which statements to execute, control statements are used to express repetition. If each line of code we wrote were only executed once, programming would be a very unproductive exercise. Only through repeated execution of statements do we unlock the full potential of computers. We have already seen one form of repetition: a function can be applied many times, although it is only defined once. Iterative control structures are another mechanism for executing the same statements many times.

Consider the sequence of Fibonacci numbers, in which each number is the sum of the preceding two:

`0, 1, 1, 2, 3, 5, 8, 13, 21, ...`

Each value is constructed by repeatedly applying the sum-previous-two rule. The first and second are fixed to 0 and 1. For instance, the eighth Fibonacci number is 13.

We can use a while statement to enumerate n Fibonacci numbers. We need to track how many values we've created (k), along with the kth value (curr) and its predecessor (pred). Step through this function and observe how the Fibonacci numbers evolve one by one, bound to curr.


<iframe width="100%" height="550" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20fib%28n%29%3A%0A%20%20%20%20%22%22%22Compute%20the%20nth%20Fibonacci%20number,%20for%20n%20%3E%3D%202.%22%22%22%0A%20%20%20%20pred,%20curr%20%3D%200,%201%20%20%20%23%20Fibonacci%20numbers%201%20and%202%0A%20%20%20%20k%20%3D%202%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%23%20Which%20Fib%20number%20is%20curr%3F%0A%20%20%20%20while%20k%20%3C%20n%3A%0A%20%20%20%20%20%20%20%20pred,%20curr%20%3D%20curr,%20pred%20%2B%20curr%0A%20%20%20%20%20%20%20%20k%20%3D%20k%20%2B%201%0A%20%20%20%20return%20curr%0A%0Aresult%20%3D%20fib%288%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

Remember that commas seperate multiple names and values in an assignment statement. The line:

`pred, curr = curr, pred + curr`

has the effect of rebinding the name pred to the value of curr, and simultanously rebinding curr to the value of `pred + curr`. All of the expressions to the right of = are evaluated before any rebinding takes place.

This order of events -- evaluating everything on the right of = before updating any bindings on the left -- is essential for correctness of this function.

A while clause contains a header expression followed by a suite:

```py
while <expression>:
    <suite>
```

To execute a while clause:

1.  Evaluate the header's expression.
2.  If it is a true value, execute the suite, then return to step 1.

In step 2, the entire suite of the while clause is executed before the header expression is evaluated again.

In order to prevent the suite of a while clause from being executed indefinitely, the suite should always change some binding in each pass.

A while statement that does not terminate is called an infinite loop. Press `<Control>-C` to force Python to stop looping.

## 1.5.6 测试

Testing a function is the act of verifying that the function's behavior matches expectations. Our language of functions is now sufficiently complex that we need to start testing our implementations.

A test is a mechanism for systematically performing this verification. Tests typically take the form of another function that contains one or more sample calls to the function being tested. The returned value is then verified against an expected result. Unlike most functions, which are meant to be general, tests involve selecting and validating calls with specific argument values. Tests also serve as documentation: they demonstrate how to call a function and what argument values are appropriate.

**Assertions.** Programmers use assert statements to verify expectations, such as the output of a function being tested. An assert statement has an expression in a boolean context, followed by a quoted line of text (single or double quotes are both fine, but be consistent) that will be displayed if the expression evaluates to a false value.

```py
>>> assert fib(8) == 13, 'The 8th Fibonacci number should be 13'
```

When the expression being asserted evaluates to a true value, executing an assert statement has no effect. When it is a false value, assert causes an error that halts execution.

A test function for fib should test several arguments, including extreme values of n.

```py
>>> def fib_test():
        assert fib(2) == 1, 'The 2nd Fibonacci number should be 1'
        assert fib(3) == 1, 'The 3rd Fibonacci number should be 1'
        assert fib(50) == 7778742049, 'Error at the 50th Fibonacci number'
```

When writing Python in files, rather than directly into the interpreter, tests are typically written in the same file or a neighboring file with the suffix _test.py.

**Doctests.** Python provides a convenient method for placing simple tests directly in the docstring of a function. The first line of a docstring should contain a one-line description of the function, followed by a blank line. A detailed description of arguments and behavior may follow. In addition, the docstring may include a sample interactive session that calls the function:

```py
>>> def sum_naturals(n):
        """Return the sum of the first n natural numbers.

        >>> sum_naturals(10)
        55
        >>> sum_naturals(100)
        5050
        """
        total, k = 0, 1
        while k <= n:
            total, k = total + k, k + 1
        return total
```

Then, the interaction can be verified via the [doctest module](http://docs.python.org/py3k/library/doctest.html). Below, the globals function returns a representation of the global environment, which the interpreter needs in order to evaluate expressions.

```py
>>> from doctest import testmod
>>> testmod()
TestResults(failed=0, attempted=2)
```

To verify the doctest interactions for only a single function, we use a doctest function called run_docstring_examples. This function is (unfortunately) a bit complicated to call. Its first argument is the function to test. The second should always be the result of the expression globals(), a built-in function that returns the global environment. The third argument is True to indicate that we would like "verbose" output: a catalog of all tests run.

```py
>>> from doctest import run_docstring_examples
>>> run_docstring_examples(sum_naturals, globals(), True)
Finding tests in NoName
Trying:
    sum_naturals(10)
Expecting:
    55
ok
Trying:
    sum_naturals(100)
Expecting:
    5050
ok
```

When the return value of a function does not match the expected result, the run_docstring_examples function will report this problem as a test failure.

When writing Python in files, all doctests in a file can be run by starting Python with the doctest command line option:

```sh
python3 -m doctest <python_source_file>
```

The key to effective testing is to write (and run) tests immediately after implementing new functions. It is even good practice to write some tests before you implement, in order to have some example inputs and outputs in your mind. A test that applies a single function is called a _unit test_. Exhaustive unit testing is a hallmark of good program design.