# 1.3 定义新的函数

:::info
译者：[Mancuoj](https://github.com/mancuoj)

协议：[CC BY-NC-SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/)

来源：[1.3 Defining New Functions](http://composingprograms.com/pages/13-defining-new-functions.html)
:::

我们已经在 Python 中确定了强大的编程语言中一些必须出现的要素：

1. 基本的内置数据和函数：数字和算术运算。
2. 组合方式：嵌套函数。
3. 受限的抽象方式：将名称与值绑定。

现在我们来学习==函数定义(function definitions)==，这是一种更为强大的抽象技术，通过它可以将名称与复合操作绑定为一个单元。

首先来研究一下平方的概念。我们可能会说：“一个数乘以它本身就是平方。” 这在 Python 中可以表示为

```py
>>> def square(x):
        return mul(x, x)
```

上面的代码定义了一个名为 `square` 的新函数，这个用户定义的函数并不会内置到解释器中，它表示将某值与自身相乘的复合运算。这个定义将 `x` 作为被乘的东西的名称，称为形式参数，同时也将此函数与名称 `square` 绑定。

如何定义函数：函数定义包含 `def` 语句、 `<name 函数名>` 和一个以逗号分隔的 `<formal parameters 形式参数>` 列表，然后是一个被称为函数体的 `return` 语句，它指定了调用函数时要计算的表达式，也就是函数的 `<return expression 返回表达式>` ：

```py
def <name>(<formal parameters>):
    return <return expression>
```

函数的第二行必须进行缩进 --> 大多数程序员使用四个空格。返回表达式会作为新定义的函数的一部分存储，并且仅在最终调用该函数时才进行求值。

定义了 `square` 之后，我们可以调用它：

```py
>>> square(21)
441
>>> square(add(2, 5))
49
>>> square(square(3))
81
```

我们还可以将 `square` 作为一个构建单元来定义其他函数。例如，我们可以很容易地定义一个函数 `sum_squares` ，给定任意两个数字作为参数，返回它们的平方和：

```py
>>> def sum_squares(x, y):
        return add(square(x), square(y))

>>> sum_squares(3, 4)
25
```

用户定义函数的使用方式与内置函数完全相同。实际上，从 `sum_squares` 的定义中我们并不能判断 `square` 是内置于解释器中，还是从模块中导入的，又或是用户定义的。

`def` 语句和赋值语句都将名称与值绑定，并且绑定后任何之前的绑定都将丢失。例如，下面的 `g` 首先指的是一个没有参数的函数，然后是指一个数字，最后是一个含有两个参数的函数。

```py
>>> def g():
        return 1
>>> g()
1
>>> g = 2
>>> g
2
>>> def g(h, i):
        return h + i
>>> g(1, 2)
3
```

## 1.3.1 环境

虽然我们现在的 Python 子集已经足够复杂，但程序的含义并不明显。如果形参与内置函数同名怎么办？两个函数可以共享名称而不会混淆吗？要解决这些问题，我们必须更详细地描述环境。

求解表达式的环境由<mark>帧(frame)</mark>的序列组成，它们可以被描述为一些盒子。每个帧都包含了一些绑定，它们将名称与对应的值相关联。<mark>全局帧(global frame)</mark>只有一个。赋值和导入语句会将条目添加到当前环境的第一帧。目前，我们的环境仅由全局帧组成。

<iframe width="100%" height="400" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=from%20math%20import%20pi%0Atau%20%3D%202%20*%20pi&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

此环境图显示了当前环境中的绑定，还有名称和值的绑定。本文中的环境图是交互式的：你可以逐步运行左侧程序的每一行，然后在右侧查看环境状态的演变。你还可以单击 “Edit code in Online Python Tutor” 以将示例加载到 [Online Python Tutor](http://composingprograms.com/tutor.html) 中。Python Tutor 是用于生成文中环境图的工具，由 [Philip Guo](http://www.pgbovine.net/) 创建。我们鼓励你自己去创建示例，研究对应生成的环境图。

函数也会出现在环境图中。`import` 语句将名称与内置函数绑定。`def` 语句将名称与用户自己定义的函数绑定。导入 `mul` 并定义 `square` 后的结果环境如下所示：

<iframe width="100%" height="400" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=from%20operator%20import%20mul%0Adef%20square%28x%29%3A%0A%20%20%20%20return%20mul%28x,%20x%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

每个函数都是一行，以 `func` 开头，后面是函数名称和形式参数。`mul` 等内置函数没有正式的参数名称，所以都是使用 `...` 代替。

函数名称重复两次，一次在环境帧中，另一次是作为函数的一部分。函数中出现的名称叫做==内在名称(intrinsic name)==。帧中的名称是==绑定名称(bound name)==。两者之间有一个区别：不同的名称可能指的是同一个函数，但该函数本身只有一个内在名称。

绑定到帧中的函数名称是在求值过程中使用。函数的内在名称在求值中不起作用。使用 Forward 按钮逐步执行下面的示例，可以看到一旦名称 `max` 与数字值 3 绑定，它就不能再用作函数。

<iframe width="100%" height="480" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=f%20%3D%20max%0Amax%20%3D%203%0Aresult%20%3D%20f%282,%203,%204%29%0Amax%281,%202%29%20%20%23%20Causes%20an%20error&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=4&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>


错误信息“TypeError: 'int' object is not callable”报告了名称 `max` （当前绑定到数字 3）是一个整数而不是函数，所以它不能用作调用表达式中的运算符。

==函数签名(function signatures)==：每个函数允许采用的参数数量有所不同。为了跟踪这些要求，我们绘制了每个函数的名称及其形式参数。用户定义的函数 `square` 只需要 `x` 一个参数，提供或多或少的参数都将导致错误。对函数形式参数的描述被称为函数的签名。

函数 `max` 可以接受任意数量的参数，它被呈现为 `max(...)`。因为原始函数从未明确定义，所以无论采用多少个参数，所有的内置函数都将呈现为 `<name>(...)`。

## 1.3.2 调用用户定义的函数

为了求出操作符为用户定义函数的调用表达式，Python 解释器遵循了以下计算过程。与其他任何调用表达式一样，解释器将对操作符和操作数表达式求值，然后用生成的实参调用具名函数。

调用用户定义的函数会引入==局部帧(local frame)==，它只能访问该函数。通过一些实参调用用户定义的函数：

1. 在新的局部帧中，将实参绑定到函数的形参上。
2. 在以此帧开始的环境中执行函数体。

求值函数体的环境由两个帧组成：一是包含形式参数绑定的局部帧，然后是包含其他所有内容的全局帧。函数的每个实例都有自己独立的局部帧。

为了详细说明一个例子，下面将会描述相同示例的环境图中的几个步骤。执行第一个 `import` 语句后，只有名称 `mul` 被绑定在全局帧中。

首先，执行定义函数 `square` 的语句。请注意，整个 `def` 语句是在一个步骤中处理的。直到函数被调用（而不是定义时），函数体才会被执行。

接下来，使用参数 `-2` 调用 `square` 函数，它会创建一个新的帧，将形式参数 `x` 与 `-2` 绑定。

<iframe width="100%" height="400" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=from%20operator%20import%20mul%0Adef%20square%28x%29%3A%0A%20%20%20%20return%20mul%28x,%20x%29%0Asquare%28-2%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

然后在当前环境中查找名称 `x` ，它由所示的两个帧组成，而在这两种情况下，`x` 的结果都是 `-2` ，因此 `square` 函数返回 4。

`square()` 帧中的“返回值”不是名称绑定的值，而是调用创建帧的函数返回的值。

即使在这个简单的示例中，也使用了两个不同的环境。顶级表达式 `square(-2)` 在全局环境中求值，而返回表达式 `mul(x, x)` 在调用 `square` 时创建的环境中求值。虽然 `x` 和 `mul` 都在这个环境中，但在不同的帧中。

环境中帧的顺序会影响通过表达式查找名称而返回的值。我们之前说过，名称会求解为当前环境中与该名称关联的值。我们现在可以更准确地说：

==名称求解==：名称的计算结果为该名称所在环境中的最早的帧中与它绑定的值。

环境、名称和函数的概念框架构成了求解模型，虽然一些机械细节仍未指定（例如，如何实现绑定），但我们的模型确实精准地描述了解释器如何求解调用表达式。在第三章中，我们将看到这个模型如何作为蓝图来实现编程语言的工作解释器。

## 1.3.3 示例：调用用户定义的函数

让我们再次思考两个简单的函数定义，并说明计算用户定义函数的调用表达式的过程。

<iframe width="100%" height="620" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=from%20operator%20import%20add,%20mul%0Adef%20square%28x%29%3A%0A%20%20%20%20return%20mul%28x,%20x%29%0A%0Adef%20sum_squares%28x,%20y%29%3A%0A%20%20%20%20return%20add%28square%28x%29,%20square%28y%29%29%0A%0Aresult%20%3D%20sum_squares%285,%2012%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

Python 首先求解名称 `sum_squares` ，并将它绑定到全局帧中的用户定义函数。原始数值表达式 5 和 12 的计算结果为它们所代表的数字。

接下来 Python 会调用 `sum_squares` ，它引入了一个局部帧，将 `x` 绑定到 5，将 `y` 绑定到 12。

`sum_squares` 的主体包含此调用表达式：

```
  add     (  square(x)  ,  square(y)  )
________     _________     _________
operator     operand 0     operand 1
```

All three subexpressions are evaluated in the current environment, which begins with the frame labeled sum_squares(). The operator subexpression add is a name found in the global frame, bound to the built-in function for addition. The two operand subexpressions must be evaluated in turn, before addition is applied. Both operands are evaluated in the current environment beginning with the frame labeled sum_squares.

In operand 0, square names a user-defined function in the global frame, while x names the number 5 in the local frame. Python applies square to 5 by introducing yet another local frame that binds x to 5.

<iframe width="100%" height="620" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=from%20operator%20import%20add,%20mul%0Adef%20square%28x%29%3A%0A%20%20%20%20return%20mul%28x,%20x%29%0A%0Adef%20sum_squares%28x,%20y%29%3A%0A%20%20%20%20return%20add%28square%28x%29,%20square%28y%29%29%0A%0Aresult%20%3D%20sum_squares%285,%2012%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

Using this environment, the expression `mul(x, x)` evaluates to 25.

Our evaluation procedure now turns to operand 1, for which y names the number 12. Python evaluates the body of square again, this time introducing yet another local frame that binds x to 12. Hence, operand 1 evaluates to 144.

<iframe width="100%" height="620" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=from%20operator%20import%20add,%20mul%0Adef%20square%28x%29%3A%0A%20%20%20%20return%20mul%28x,%20x%29%0A%0Adef%20sum_squares%28x,%20y%29%3A%0A%20%20%20%20return%20add%28square%28x%29,%20square%28y%29%29%0A%0Aresult%20%3D%20sum_squares%285,%2012%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

Finally, applying addition to the arguments 25 and 144 yields a final return value for `sum_squares`: 169.

<iframe width="100%" height="620" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=from%20operator%20import%20add,%20mul%0Adef%20square%28x%29%3A%0A%20%20%20%20return%20mul%28x,%20x%29%0A%0Adef%20sum_squares%28x,%20y%29%3A%0A%20%20%20%20return%20add%28square%28x%29,%20square%28y%29%29%0A%0Aresult%20%3D%20sum_squares%285,%2012%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

This example illustrates many of the fundamental ideas we have developed so far. Names are bound to values, which are distributed across many independent local frames, along with a single global frame that contains shared names. A new local frame is introduced every time a function is called, even if the same function is called twice.

All of this machinery exists to ensure that names resolve to the correct values at the correct times during program execution. This example illustrates why our model requires the complexity that we have introduced. All three local frames contain a binding for the name x, but that name is bound to different values in different frames. Local frames keep these names separate.

## 1.3.4 局部名称

One detail of a function's implementation that should not affect the function's behavior is the implementer's choice of names for the function's formal parameters. Thus, the following functions should provide the same behavior:

```py
>>> def square(x):
        return mul(x, x)
>>> def square(y):
        return mul(y, y)
```


This principle -- that the meaning of a function should be independent of the parameter names chosen by its author -- has important consequences for programming languages. The simplest consequence is that the parameter names of a function must remain local to the body of the function.

If the parameters were not local to the bodies of their respective functions, then the parameter x in square could be confused with the parameter x in sum_squares. Critically, this is not the case: the binding for x in different local frames are unrelated. The model of computation is carefully designed to ensure this independence.

We say that the _scope_ of a local name is limited to the body of the user-defined function that defines it. When a name is no longer accessible, it is out of scope. This scoping behavior isn't a new fact about our model; it is a consequence of the way environments work.


## 1.3.5 选择名称

The interchangeability of names does not imply that formal parameter names do not matter at all. On the contrary, well-chosen function and parameter names are essential for the human interpretability of function definitions!

The following guidelines are adapted from the [style guide for Python code](http://www.python.org/dev/peps/pep-0008), which serves as a guide for all (non-rebellious) Python programmers. A shared set of conventions smooths communication among members of a developer community. As a side effect of following these conventions, you will find that your code becomes more internally consistent.

1.  Function names are lowercase, with words separated by underscores. Descriptive names are encouraged.
2.  Function names typically evoke operations applied to arguments by the interpreter (e.g., print, add, square) or the name of the quantity that results (e.g., max, abs, sum).
3.  Parameter names are lowercase, with words separated by underscores. Single-word names are preferred.
4.  Parameter names should evoke the role of the parameter in the function, not just the kind of argument that is allowed.
5.  Single letter parameter names are acceptable when their role is obvious, but avoid "l" (lowercase ell), "O" (capital oh), or "I" (capital i) to avoid confusion with numerals.

There are many exceptions to these guidelines, even in the Python standard library. Like the vocabulary of the English language, Python has inherited words from a variety of contributors, and the result is not always consistent.

## 1.3.6 作为抽象的函数

Though it is very simple, sum_squares exemplifies the most powerful property of user-defined functions. The function sum_squares is defined in terms of the function square, but relies only on the relationship that square defines between its input arguments and its output values.

We can write sum_squares without concerning ourselves with _how_ to square a number. The details of how the square is computed can be suppressed, to be considered at a later time. Indeed, as far as sum_squares is concerned, square is not a particular function body, but rather an abstraction of a function, a so-called functional abstraction. At this level of abstraction, any function that computes the square is equally good.

Thus, considering only the values they return, the following two functions for squaring a number should be indistinguishable. Each takes a numerical argument and produces the square of that number as the value.

```py
>>> def square(x):
        return mul(x, x)
>>> def square(x):
        return mul(x, x-1) + x
```

In other words, a function definition should be able to suppress details. The users of the function may not have written the function themselves, but may have obtained it from another programmer as a "black box". A programmer should not need to know how the function is implemented in order to use it. The Python Library has this property. Many developers use the functions defined there, but few ever inspect their implementation.

**Aspects of a functional abstraction.** To master the use of a functional abstraction, it is often useful to consider its three core attributes. The _domain_ of a function is the set of arguments it can take. The _range_ of a function is the set of values it can return. The _intent_ of a function is the relationship it computes between inputs and output (as well as any side effects it might generate). Understanding functional abstractions via their domain, range, and intent is critical to using them correctly in a complex program.

For example, any square function that we use to implement sum_squares should have these attributes:

-   The _domain_ is any single real number.
-   The _range_ is any non-negative real number.
-   The _intent_ is that the output is the square of the input.

These attributes do not specify how the intent is carried out; that detail is abstracted away.

## 1.3.7 操作符

Mathematical operators (such as + and -) provided our first example of a method of combination, but we have yet to define an evaluation procedure for expressions that contain these operators.

Python expressions with infix operators each have their own evaluation procedures, but you can often think of them as short-hand for call expressions. When you see

```py
>>> 2 + 3
5
```

simply consider it to be short-hand for

```py
>>> add(2, 3)
5
```

Infix notation can be nested, just like call expressions. Python applies the normal mathematical rules of operator precedence, which dictate how to interpret a compound expression with multiple operators.

```py
>>> 2 + 3 * 4 + 5
19
```

evaluates to the same result as

```py
>>> add(add(2, mul(3, 4)), 5)
19
```

The nesting in the call expression is more explicit than the operator version, but also harder to read. Python also allows subexpression grouping with parentheses, to override the normal precedence rules or make the nested structure of an expression more explicit.

```py
>>> (2 + 3) * (4 + 5)
45
```

evaluates to the same result as

```py
>>> mul(add(2, 3), add(4, 5))
45
```

When it comes to division, Python provides two infix operators: / and //. The former is normal division, so that it results in a _floating point_, or decimal value, even if the divisor evenly divides the dividend:

```py
>>> 5 / 4
1.25
>>> 8 / 4
2.0
```

The // operator, on the other hand, rounds the result down to an integer:

```py
>>> 5 // 4
1
>>> -5 // 4
-2
```

These two operators are shorthand for the truediv and floordiv functions.

```py
>>> from operator import truediv, floordiv
>>> truediv(5, 4)
1.25
>>> floordiv(5, 4)
1
```

You should feel free to use infix operators and parentheses in your programs. Idiomatic Python prefers operators over call expressions for simple mathematical operations.