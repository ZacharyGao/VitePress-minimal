# 1.3 定义新的函数

我们已经在 Python 中确定了强大的编程语言中一些必须出现的要素：

1. ==基本==的内置数据和函数：数字和算术运算。
2. ==组合==方式：嵌套函数。
3. 受限的==抽象==方式：将名称与值绑定。

现在我们来学习==函数定义==，这是一种更为强大的抽象技术，通过它可以将名称与复合操作绑定为一个单元。

首先来研究一下==平方==的概念。我们可能会说：“一个数乘以它本身就是平方。” 这在 Python 中可以表示为

```py
>>> def square(x):
        return mul(x, x)
```

上面的代码定义了一个名为 `square` 的新函数，这个用户定义的函数并不会内置到解释器中，它表示将某值与自身相乘的复合运算。这个定义将 `x` 作为被乘的东西的名称，称为==形参（形式参数）==，同时也将此函数与名称 `square` 绑定。

==如何定义函数==：函数定义包含 `def` 语句、 `<name 函数名>` 和一个以逗号分隔的 `<formal parameters 形参>` 列表，然后是一个被称为函数体的 `return` 语句，它指定了调用函数时要计算的表达式，也就是函数的 `<return expression 返回表达式>` ：

```py
def <name>(<formal parameters>):
    return <return expression>
```

函数的第二行==必须==进行缩进 —— 大多数程序员使用四个空格。返回表达式会作为新定义的函数的一部分存储，并且仅在最终调用该函数时才进行求值。

定义了 `square` 之后，我们可以调用它：

```py
>>> square(21)
441
>>> square(add(2, 5))
49
>>> square(square(3))
81
```

我们还可以将 `square` 作为一个构建单元来定义其他函数。例如，我们可以很容易地定义一个函数 `sum_squares` ，给定任意两个数字作为参数，返回它们的平方和：

```py
>>> def sum_squares(x, y):
        return add(square(x), square(y))

>>> sum_squares(3, 4)
25
```

用户定义函数的使用方式与内置函数完全相同。实际上，从 `sum_squares` 的定义中我们并不能判断 `square` 是内置于解释器中，还是从模块中导入的，又或是由用户定义的。

`def` 语句和赋值语句都将名称与值绑定，并且绑定后任何之前的绑定都将丢失。例如，下面的 `g` 首先指的是一个没有参数的函数，然后是指一个数字，最后是一个含有两个参数的函数。

```py
>>> def g():
        return 1
>>> g()
1
>>> g = 2
>>> g
2
>>> def g(h, i):
        return h + i
>>> g(1, 2)
3
```

## 1.3.1 环境

我们的 Python 子集现在已经足够复杂，以至于程序的含义并不明显。如果形式参数与内置函数同名怎么办？两个函数可以共享名称而不会混淆吗？要解决这些问题，我们必须更详细地描述环境。

评估表达式的环境由一系列帧组成，描述为框。每个框架都包含绑定，每个绑定都将一个名称与其对应的值相关联。有一个单一的全球框架。赋值和导入语句将条目添加到当前环境的第一帧。到目前为止，我们的环境仅由全局框架组成。
求解表达式的环境由帧序列组成，可以表述为一个盒子。每个帧都包含了一些绑定，它们将名称与对应的值相关联。全局帧只有一个，赋值和导入语句会将条目添加到当前环境的第一帧，到目前为止，我们的环境仅由全局帧组成，[具体请点击 Python Tutor 查看](http://composingprograms.com/tutor.html#code=from+math+import+pi%0Atau+%3D+2+*+pi)。


![pt_1](/sicp-python/pt_1.png)

This _environment diagram_ shows the bindings of the current environment, along with the values to which names are bound. The environment diagrams in this text are interactive: you can step through the lines of the small program on the left to see the state of the environment evolve on the right. You can also click on the "Edit code in Online Python Tutor" link to load the example into the [Online Python Tutor](http://composingprograms.com/tutor.html), a tool created by [Philip Guo](http://www.pgbovine.net/) for generating these environment diagrams. You are encouraged to create examples yourself and study the resulting environment diagrams.

Functions appear in environment diagrams as well. An import statement binds a name to a built-in function. A def statement binds a name to a user-defined function created by the definition. The resulting environment after importing mul and defining square appears below:

![pt_2](/sicp-python/pt_2.png)



Each function is a line that starts with func, followed by the function name and formal parameters. Built-in functions such as mul do not have formal parameter names, and so ... is always used instead.

The name of a function is repeated twice, once in the frame and again as part of the function itself. The name appearing in the function is called the _intrinsic name_. The name in a frame is a _bound name_. There is a difference between the two: different names may refer to the same function, but that function itself has only one intrinsic name.

The name bound to a function in a frame is the one used during evaluation. The intrinsic name of a function does not play a role in evaluation. Step through the example below using the _Forward_ button to see that once the name max is bound to the value 3, it can no longer be used as a function.

![pt_3](/sicp-python/pt_3.png)


The error message TypeError: 'int' object is not callable is reporting that the name max (currently bound to the number 3) is an integer and not a function. Therefore, it cannot be used as the operator in a call expression.

**Function Signatures.** Functions differ in the number of arguments that they are allowed to take. To track these requirements, we draw each function in a way that shows the function name and its formal parameters. The user-defined function square takes only x; providing more or fewer arguments will result in an error. A description of the formal parameters of a function is called the function's signature.

The function max can take an arbitrary number of arguments. It is rendered as `max(...)`. Regardless of the number of arguments taken, all built-in functions will be rendered as `<name>(...)`, because these primitive functions were never explicitly defined.

## 1.3.2 调用用户定义的函数

To evaluate a call expression whose operator names a user-defined function, the Python interpreter follows a computational process. As with any call expression, the interpreter evaluates the operator and operand expressions, and then applies the named function to the resulting arguments.

Applying a user-defined function introduces a second _local_ frame, which is only accessible to that function. To apply a user-defined function to some arguments:

1.  Bind the arguments to the names of the function's formal parameters in a new _local_ frame.
2.  Execute the body of the function in the environment that starts with this frame.

The environment in which the body is evaluated consists of two frames: first the local frame that contains formal parameter bindings, then the global frame that contains everything else. Each instance of a function application has its own independent local frame.

To illustrate an example in detail, several steps of the environment diagram for the same example are depicted below. After executing the first import statement, only the name mul is bound in the global frame.

