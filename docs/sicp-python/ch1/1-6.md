# 1.6 高阶函数

:::info
译者：[Mancuoj](https://github.com/mancuoj)

协议：[CC BY-NC-SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/)

来源：[1.6 Higher-Order Functions](http://composingprograms.com/pages/16-higher-order-functions.html)
:::

我们已经看到，函数其实是一种抽象方法，它描述了与特定参数值无关的的复合操作。

```py
>>> def square(x):
        return x * x
```

也就是说，在 `square` 中我们并不是在讨论一个特定数字的平方，而是在讨论一种获得任何数字平方的方法。当然，我们也可以在不定义这个函数的情况下得到结果，而是通过写下面的表达式来计算平方，并且从不显式地提到 `square`。

```py
>>> 3 * 3
9
>>> 5 * 5
25
```

这种做法对于诸如 `square` 之类的简单计算是足够的，但对于诸如 `abs` 或 `fib` 之类的更复杂的样例就会变得很费力。一般来说，缺少函数定义会对我们非常不利，它会迫使我们总是工作在特定的基础的操作级别（本例中为乘法），而不是更高的操作级别。我们的程序将能够计算平方，但缺少表达平方的概念的能力。

我们对强大的编程语言提出的要求之一就是能够通过将名称分配给通用模板（general patterns）来构建抽象，然后直接使用该名称进行工作。函数提供了这种能力。正如我们将在下面的示例中看到的那样，代码中重复出现了一些常见的编程模板，但它们可以与许多不同的函数一起使用。这些模板也可以通过给它们命名来进行抽象。

为了将某些通用模板表达为具名概念（named concepts），我们需要构造一种“可以接收其他函数作为参数”或“可以把函数当作返回值”的函数。这种可以操作函数的函数就叫做高阶函数（higher-order functions）。本节将会展示：高阶函数可以作为一种强大的抽象机制，来极大地提高我们语言的表达能力。

## 1.6.1 作为参数的函数

思考以下三个计算求和的函数。第一个 `sum_naturals` 计算直到 `n` 的自然数之和：

```py
>>> def sum_naturals(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + k, k + 1
        return total

>>> sum_naturals(100)
5050
```

第二个 `sum_cubes` 函数计算直到 `n` 的自然数的立方之和。

```py
>>> def sum_cubes(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + k*k*k, k + 1
        return total

>>> sum_cubes(100)
25502500
```

第三个 `pi_sum` 计算下列各项的总和，它会非常缓慢地收敛到 $\pi$ 。

<!-- ![pi_sum](/sicp-python/pi_sum.png) -->
$$
\frac{8}{1\cdot 3} + \frac{8}{5\cdot 7} + \frac{8}{9\cdot 11} + \dots
$$

```py
>>> def pi_sum(n):
        total, k = 0, 1
        while k <= n:
            total, k = total + 8 / ((4*k-3) * (4*k-1)), k + 1
        return total

>>> pi_sum(100)
3.1365926848388144
```

这三个函数显然在背后共享着一个通用的模板（pattern）。它们在很大程度上是相同的，仅在名称和用于计算被加项 `k` 的函数上有所不同。我们可以通过在同一模板中填充槽位（slots）来生成每个函数：

```py
def <name>(n):
    total, k = 0, 1
    while k <= n:
        total, k = total + <term>(k), k + 1
    return total
```

这种通用模板的存在是一个强有力的证据 --> 表明了有一个实用的抽象手段正在“浮出水面”。这些函数都是用于求出各项的总和。作为程序设计者，我们希望我们的语言足够强大，以便我们可以编写一个表达“求和”这个概念本身的函数，而不仅仅是一个计算特定和的函数。在 Python 中，我们可以很轻易地做到这一点，方法就是使用上面展示的通用模板，并且将“槽位”转换为形式参数：

在下面的示例中，`summation` 函数将上界 `n` 和计算第 `k` 项的函数 `term` 作为其两个参数。我们可以像使用任何函数一样使用 `summation` ，它简洁地表达了求和。花点时间单步调试（step through）走完这个示例，注意函数如何将 `cube` 绑定到局部名称 `term` 上以确保 $1\times 1\times 1 + 2\times 2\times 2 + 3\times 3\times 3 = 36$ 计算结果正确。

<iframe width="100%" height="800" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20summation%28n,%20term%29%3A%0A%20%20%20%20total,%20k%20%3D%200,%201%0A%20%20%20%20while%20k%20%3C%3D%20n%3A%0A%20%20%20%20%20%20%20%20total,%20k%20%3D%20total%20%2B%20term%28k%29,%20k%20%2B%201%0A%20%20%20%20return%20total%0A%0Adef%20cube%28x%29%3A%0A%20%20%20%20return%20x*x*x%0A%0Adef%20sum_cubes%28n%29%3A%0A%20%20%20%20return%20summation%28n,%20cube%29%0A%0Aresult%20%3D%20sum_cubes%283%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

使用会返回其参数的 `identity` 函数，我们还可以使用完全相同的 `summation` 函数对自然数求和。

```py
>>> def summation(n, term):
        total, k = 0, 1
        while k <= n:
            total, k = total + term(k), k + 1
        return total
>>> def identity(x):
        return x
>>> def sum_naturals(n):
        return summation(n, identity)
>>> sum_naturals(10)
55
```

`summation` 函数也可以直接调用，而无需为特定的数列去定义另一个函数。

```py
>>> summation(10, square)
385
```

可以定义 `pi_term` 函数来计算每一项的值，从而使用我们对 `summation` 的抽象来定义 `pi_sum` 函数。传入参数 `1e6`（1 * 10<sup>6</sup> = 1000000 的简写）以计算 $\pi$ 的近似值。

```py
>>> def pi_term(x):
        return 8 / ((4*x-3) * (4*x-1))
>>> def pi_sum(n):
        return summation(n, pi_term)
>>> pi_sum(1e6)
3.141592153589902
```

## 1.6.2 作为通用方法的函数

之前我们引入了“用户定义函数（user-defined functions）”作为一种数值运算的抽象模式，从而使它们与涉及的特定数字无关。有了高阶函数后，我们会看到一种更强大的抽象：用一些函数来表达计算的通用方法（general methods），而且和它们调用的特定函数无关。

尽管我们对函数的意义进行了这些概念上的扩展，但我们用于查看“调用表达式如何求解”的环境模型可以优雅地、无需更改地扩展到高阶函数。当将用户定义的函数应用于某些参数时，形式参数将与局部帧中它们的值（参数可能是函数）绑定。

思考下面的例子，它实现了迭代改进（iterative improvement）的通用方法，并使用它来计算黄金比例。[黄金比例](http://www.geom.uiuc.edu/~demo5337/s97b/art.htm)，通常被称为“phi”，是一个接近 1.6 的数字，经常出现在自然、艺术和建筑中。

迭代改进算法从方程的 `guess` 解（推测值）开始，重复应用 `update` 函数来改进该猜测，并调用 `close` 比较来检查当前的 `guess` 是否已经“足够接近”正确值。

```py
>>> def improve(update, close, guess=1):
        while not close(guess):
            guess = update(guess)
        return guess
```

这个 `improve` 函数是迭代求精（repetitive refinement）的通用表达式。它并不会指定要解决的问题，而是会将这些细节留给作为参数传入的 `update` 和 `close` 函数。

黄金比例的一个著名的特性是它可以通过反复叠加任何正数的倒数加上 1 来计算，而且它比它的平方小 1。我们可以将这些特性表示为与 `improve` 一起使用的函数。

```py
>>> def golden_update(guess):
        return 1/guess + 1

>>> def square_close_to_successor(guess):
        return approx_eq(guess * guess, guess + 1)
```

以上，我们调用了 `approx_eq` 函数：如果其参数大致相等，则返回 `True`。为了实现 `approx_eq` ，我们可以将两个数字差的绝对值与一个小的公差值（tolerance value）进行比较。

```py
>>> def approx_eq(x, y, tolerance=1e-15):
        return abs(x - y) < tolerance
```

使用参数 `golden_update` 和 `square_close_to_successor` 来调用 `improve` 将会计算出黄金比例的有限近似值。

```py
>>> improve(golden_update, square_close_to_successor)
1.6180339887498951
```

通过追踪求解的步骤，我们可以看到这个结果是如何计算出来的。首先，将 `update`、`close` 和 `guess` 绑定在构造 `improve` 的局部帧上。然后在 `improve` 的函数体中，将名称 `close` 绑定到 `square_close_to_successor` ，它会使用 `guess` 的初始值进行调用。跟踪其余步骤来查看其逐步演变为黄金比例的计算过程。

<iframe width="100%" height="800" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20improve%28update,%20close,%20guess%3D1%29%3A%0A%20%20%20%20while%20not%20close%28guess%29%3A%0A%20%20%20%20%20%20%20%20guess%20%3D%20update%28guess%29%0A%20%20%20%20return%20guess%0A%0Adef%20golden_update%28guess%29%3A%0A%20%20%20%20return%201/guess%20%2B%201%0A%0Adef%20square_close_to_successor%28guess%29%3A%0A%20%20%20%20return%20approx_eq%28guess%20*%20guess,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20guess%20%2B%201%29%0A%0Adef%20approx_eq%28x,%20y,%20tolerance%3D1e-3%29%3A%0A%20%20%20%20return%20abs%28x%20-%20y%29%20%3C%20tolerance%0A%0Aphi%20%3D%20improve%28golden_update,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20%20square_close_to_successor%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

这个例子说明了计算机科学中两个相关的重要思想：首先，命名和函数使我们能将大量的复杂事物进行抽象。虽然每个函数定义都很简单，但我们的求解程序触发的计算过程非常复杂。其次，正是由于我们对 Python 语言有一个极其通用的求解过程，小的组件才能组合成复杂的程序。理解这解释程序的求解过程会有便于我们验证和检查我们创建的程序。

一如既往，我们的新通用方法 `improve` 需要测试来检查其正确性。黄金比例可以提供这样的测试，因为它有一个精确的闭式解，所以我们可以将这个解与迭代结果进行比较。

```py
>>> from math import sqrt
>>> phi = 1/2 + sqrt(5)/2
>>> def improve_test():
        approx_phi = improve(golden_update, square_close_to_successor)
        assert approx_eq(phi, approx_phi), 'phi differs from its approximation'
>>> improve_test()
```

对于这个测试，没有消息就是好消息：`improve_test` 函数在 `assert` 语句执行成功后会返回 `None`。

## 1.6.3 定义函数 III：嵌套定义

上面的示例演示了将函数作为参数传递的能力显著地增强编程语言的表达能力。每个通用概念或方程都能映射到自己的小型函数上，但这种方法的一个负面后果是全局帧会变得混乱，因为小型函数的名称必须都是唯一的。另一个问题是我们受到特定函数签名的限制：`improve` 的 `update` 参数只能接受一个参数。嵌套函数定义（Nested function definition）解决了这两个问题，但需要我们丰富一下环境模型。

让我们思考一个新问题：计算一个数的平方根。在编程语言中，“平方根”通常缩写为 `sqrt`。重复应用以下更新会收敛到 `a` 的平方根：

```py
>>> def average(x, y):
        return (x + y)/2

>>> def sqrt_update(x, a):
        return average(x, a/x)
```

这个双参数更新函数与 `improve` 函数不兼容（它有两个参数，而不是一个），而且它只提供一次更新，但我们真正想要的是通过重复更新求平方根。这两个问题的解决方案是将函数定义放在其他函数定义的主体中。

```py
>>> def sqrt(a):
        def sqrt_update(x):
            return average(x, a/x)
        def sqrt_close(x):
            return approx_eq(x * x, a)
        return improve(sqrt_update, sqrt_close)
```

与局部赋值一样，局部 `def` 语句只影响当前局部帧。这些函数仅在求解 `sqrt` 时在作用域内。与求解过程一致，这些局部 `def` 语句在调用 `sqrt` 之前都不会被求解。

==词法作用域（Lexical scope）==：局部定义的函数也可以访问定义作用域内的名称绑定。在此示例中， `sqrt_update` 引用名称 `a`，它是其封闭函数 `sqrt` 的形式参数。这种在嵌套定义之间共享名称的规则称为词法作用域。最重要的是，内部函数可以访问定义它们的环境中的名称（而不是它们被调用的位置）。

我们需要对我们的环境模型实现两个扩展来启用词法作用域。

1. 每个用户定义的函数都有一个父环境：定义它的环境。
2. 调用用户定义的函数时，其局部帧会继承其父环境。

在调用 `sqrt` 之前，所有函数都是在全局环境中定义的，因此它们都有相同的父级：全局环境。相比之下，当 Python 计算 `sqrt` 的前两个子句时，它会创建与本地环境关联的函数。在这次调用中

```py
>>> sqrt(256)
16.0
```

环境首先为 `sqrt` 添加一个局部帧，然后求解 `sqrt_update` 和 `sqrt_close` 的 def 语句。

<iframe width="100%" height="800" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20average%28x,%20y%29%3A%0A%20%20%20%20return%20%28x%20%2B%20y%29/2%0A%0Adef%20improve%28update,%20close,%20guess%3D1%29%3A%0A%20%20%20%20while%20not%20close%28guess%29%3A%0A%20%20%20%20%20%20%20%20guess%20%3D%20update%28guess%29%0A%20%20%20%20return%20guess%0A%0Adef%20approx_eq%28x,%20y,%20tolerance%3D1e-3%29%3A%0A%20%20%20%20return%20abs%28x%20-%20y%29%20%3C%20tolerance%0A%0Adef%20sqrt%28a%29%3A%0A%20%20%20%20def%20sqrt_update%28x%29%3A%0A%20%20%20%20%20%20%20%20return%20average%28x,%20a/x%29%0A%20%20%20%20def%20sqrt_close%28x%29%3A%0A%20%20%20%20%20%20%20%20return%20approx_eq%28x%20*%20x,%20a%29%0A%20%20%20%20return%20improve%28sqrt_update,%20sqrt_close%29%0A%0Aresult%20%3D%20sqrt%28256%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

从现在开始我们将在环境图中的每个函数都增加一个新注释 --> 父级注释（a parent annotation）。函数的父级是定义该函数的环境的第一帧。没有父级注释的函数是在全局环境中定义的。当调用用户定义的函数时，创建的帧与该函数具有相同的父级。

随后，名称 `sqrt_update` 解析为这个新定义的函数，该函数作为参数传给函数 `improve` 。在 `improve` 函数的函数体中，我们必须以猜测的初始值 `x` 为 1 来调用 `update` 函数（绑定到 `sqrt_update` ）。这个最后的程序调用为 `sqrt_update` 创建了一个环境，它以一个仅包含 `x` 的本地帧开始，但父帧 `sqrt` 仍然包含 `a` 的绑定。

这个求值过程中最终的部分，是将 `sqrt_update` 的父环境变成了通过调用 `sqrt_update` 创建的（局部）帧。此帧用`[parent=f1]` 进行注释。

继承环境（Extended Environments）：一个环境由一长串帧构成，并且总是以全局帧结束。在举 `sqrt` 这个例子之前，环境最多只包含两种帧：局部帧和全局帧。使用嵌套的 `def` 语句来调用在其他函数中定义的函数，我们可以创建更长的（帧）链。调用 `sqrt_update` 的环境由三个帧组成：局部帧 `sqrt_update` 、定义`sqrt_update` 的 `sqrt` 帧（标记为 `f1`）和全局帧。

`sqrt_update` 函数体中的返回表达式可以通过遵循这一帧链来解析 `a` 的值。查找名称会找到当前环境中绑定到该名称的第一个值。Python 首先在 `sqrt_update` 帧中进行检查 --> 不存在 `a` ，然后又到 `sqrt_update` 的父帧 `f1` 中进行检查，发现 `a` 被绑定到了 256。

因此，我们发现了 Python 中词法作用域的两个关键优势。

- 局部函数的名称不会影响定义它的函数的外部名称，因为局部函数的名称将绑定在定义它的当前局部环境中，而不是全局环境中。
- 局部函数可以访问外层函数的环境，这是因为局部函数的函数体的求值环境会继承定义它的求值环境。

这里的 `sqrt_update` 函数自带了一些数据：`a` 在定义它的环境中引用的值，因为它以这种方式“封装”信息，所以局部定义的函数通常被称为==闭包（closures）==。

## 1.6.4 作为返回值的函数

程序可以通过创建返回值本身就是函数的函数以获得更多的表现力。带有词法作用域的编程语言的一个重要特性就是，局部定义函数在它们返回时仍旧持有所关联的环境。下面的例子展示了这一特性的作用。

一旦定义了许多简单的函数，函数组合（composition）就成为编程语言中的一种自然的组合方法。也就是说，给定两个函数 `f(x)` 和 `g(x)`，我们可能想要定义 `h(x) = f(g(x))` 。我们可以使用我们现有的工具来定义函数组合：

```py
>>> def compose1(f, g):
        def h(x):
            return f(g(x))
        return h
```

此示例的环境图展示了如何正确解析名称 `f` 和 `g` ，即使它们存在名称冲突。

<iframe width="100%" height="800" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20square%28x%29%3A%0A%20%20%20%20return%20x%20*%20x%0A%0Adef%20successor%28x%29%3A%0A%20%20%20%20return%20x%20%2B%201%0A%0Adef%20compose1%28f,%20g%29%3A%0A%20%20%20%20def%20h%28x%29%3A%0A%20%20%20%20%20%20%20%20return%20f%28g%28x%29%29%0A%20%20%20%20return%20h%0A%0Adef%20f%28x%29%3A%0A%20%20%20%20%22%22%22Never%20called.%22%22%22%0A%20%20%20%20return%20-x%0A%0Asquare_successor%20%3D%20compose1%28square,%20successor%29%0Aresult%20%3D%20square_successor%2812%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

`compose1` 中的 1 表示这个组合的函数只有一个参数。这个命名惯例不是解释器强制要求的，1 只是函数名的一部分而已。

在这一点上，我们已经能够察觉到到努力去精确定义计算环境模型的好处：获得了不需要修改环境模型来解释我们以这种方式来返回函数的能力。

## 1.6.5 示例: 牛顿法

这个扩展的示例展示了函数返回值和局部定义如何协同工作，以简洁地表达一般的思想。我们将实现一种广泛用于机器学习、科学计算、硬件设计和优化的算法。

牛顿法（Newton's method）是一种经典的迭代方法，用于查找返回值为 0 的数学函数的参数。这些值（参数）称为函数的零点（Zeros）。找到函数的零点通常等同于解决了其他一些有趣的问题，例如求平方根。

在我们继续之前，有一个激励人心的评论说到：我们很容易想当然地认为我们知道如何计算平方根。不止是 Python，你的手机、网页浏览器或袖珍计算器都可以为你做到这一点。然而，学习计算机科学的一部分是理解这样的量如如何进行计算的，此处介绍的一般方法适用于求解 Python 内置方程之外的一大类方程。

牛顿法是一种迭代改进算法：它会对所有可微（differentiable）函数的零点的猜测值进行改进，这意味着它可以在任意点用直线进行近似处理。牛顿的方法遵循这些线性近似（linear approximations）来找到函数零点。

试想一条穿过点 $(x,f(x))$ 的直线与函数 $f(x)$ 在该点拥有相同的斜率。这样的直线我们称之为切线（tangent），它的斜率我们称之为 $f$ 在 $x$ 处的导数（derivative）。

这条直线的斜率是函数值变化量与函数自变量的比值。所以，按照 $f(x)$ 除以这个斜率来平移 $x$ ，就会得到切线到达 0 时的自变量的值。

![newton](/sicp-python/newton.png)

`newton_update` 表示函数 $f$ 及其导数 $df$ 沿着这条切线到 0 的计算过程。

```py
>>> def newton_update(f, df):
        def update(x):
            return x - f(x) / df(x)
        return update
```

Finally, we can define the find_root function in terms of newton_update, our improve algorithm, and a comparison to see if f(x) is near 0.

```py
>>> def find_zero(f, df):
        def near_zero(x):
            return approx_eq(f(x), 0)
        return improve(newton_update(f, df), near_zero)
```

**Computing Roots.** Using Newton's method, we can compute roots of arbitrary degree n. The degree n root of a is x such that x⋅x⋅x…x=a with x repeated n times. For example,

-   The square (second) root of 64 is 8, because 8⋅8=648⋅8=64.
-   The cube (third) root of 64 is 4, because 4⋅4⋅4=644⋅4⋅4=64.
-   The sixth root of 64 is 2, because 2⋅2⋅2⋅2⋅2⋅2=642⋅2⋅2⋅2⋅2⋅2=64.

We can compute roots using Newton's method with the following observations:

-   The square root of 64 (written $√64$) is the value $x$ such that $x2−64=0$
-   More generally, the degree n root of a (written a−−√n) is the value x such that $xn−a=0$

If we can find a zero of this last equation, then we can compute degree n roots. By plotting the curves for n equal to 2, 3, and 6 and a equal to 64, we can visualize this relationship.

![curves](/sicp-python/curves.png)


We first implement square_root by defining f and its derivative df. We use from calculus the fact that the derivative of $f(x)=x2−a$ is the linear function $df(x)=2x$.

```py
>>> def square_root_newton(a):
        def f(x):
            return x * x - a
        def df(x):
            return 2 * x
        return find_zero(f, df)

>>> square_root_newton(64)
8.0
```

Generalizing to roots of arbitrary degree $n$, we compute $f(x)=xn−a$ and its derivative $df(x)=n⋅xn−1$.

```py
>>> def power(x, n):
        """Return x * x * x * ... * x for x repeated n times."""
        product, k = 1, 0
        while k < n:
            product, k = product * x, k + 1
        return product

>>> def nth_root_of_a(n, a):
        def f(x):
            return power(x, n) - a
        def df(x):
            return n * power(x, n-1)
        return find_zero(f, df)

>>> nth_root_of_a(2, 64)
8.0
>>> nth_root_of_a(3, 64)
4.0
>>> nth_root_of_a(6, 64)
2.0
```

The approximation error in all of these computations can be reduced by changing the tolerance in approx_eq to a smaller number.

As you experiment with Newton's method, be aware that it will not always converge. The initial guess of improve must be sufficiently close to the zero, and various conditions about the function must be met. Despite this shortcoming, Newton's method is a powerful general computational method for solving differentiable equations. Very fast algorithms for logarithms and large integer division employ variants of the technique in modern computers.

## 1.6.6 柯里化

We can use higher-order functions to convert a function that takes multiple arguments into a chain of functions that each take a single argument. More specifically, given a function f(x, y), we can define a function g such that g(x)(y) is equivalent to f(x, y). Here, g is a higher-order function that takes in a single argument x and returns another function that takes in a single argument y. This transformation is called currying.

As an example, we can define a curried version of the pow function:

```py
>>> def curried_pow(x):
        def h(y):
            return pow(x, y)
        return h
>>> curried_pow(2)(3)
8
```

Some programming languages, such as Haskell, only allow functions that take a single argument, so the programmer must curry all multi-argument procedures. In more general languages such as Python, currying is useful when we require a function that takes in only a single argument. For example, the map pattern applies a single-argument function to a sequence of values. In later chapters, we will see more general examples of the map pattern, but for now, we can implement the pattern in a function:

```py
>>> def map_to_range(start, end, f):
        while start < end:
            print(f(start))
            start = start + 1
```

We can use map_to_range and curried_pow to compute the first ten powers of two, rather than specifically writing a function to do so:

```py
>>> map_to_range(0, 10, curried_pow(2))
1
2
4
8
16
32
64
128
256
512
```

We can similarly use the same two functions to compute powers of other numbers. Currying allows us to do so without writing a specific function for each number whose powers we wish to compute.

In the above examples, we manually performed the currying transformation on the pow function to obtain curried_pow. Instead, we can define functions to automate currying, as well as the inverse uncurrying transformation:

```py
>>> def curry2(f):
        """Return a curried version of the given two-argument function."""
        def g(x):
            def h(y):
                return f(x, y)
            return h
        return g
>>> def uncurry2(g):
        """Return a two-argument version of the given curried function."""
        def f(x, y):
            return g(x)(y)
        return f
>>> pow_curried = curry2(pow)
>>> pow_curried(2)(5)
32
>>> map_to_range(0, 10, pow_curried(2))
1
2
4
8
16
32
64
128
256
512
```

The curry2 function takes in a two-argument function f and returns a single-argument function g. When g is applied to an argument x, it returns a single-argument function h. When h is applied to y, it calls f(x, y). Thus, curry2(f)(x)(y) is equivalent to f(x, y). The uncurry2 function reverses the currying transformation, so that uncurry2(curry2(f)) is equivalent to f.

```py
>>> uncurry2(pow_curried)(2, 5)
32
```

## 1.6.7 Lambda 表达式

So far, each time we have wanted to define a new function, we needed to give it a name. But for other types of expressions, we don't need to associate intermediate values with a name. That is, we can compute a*b + c*d without having to name the subexpressions a*b or c*d, or the full expression. In Python, we can create function values on the fly using lambda expressions, which evaluate to unnamed functions. A lambda expression evaluates to a function that has a single return expression as its body. Assignment and control statements are not allowed.

```py
>>> def compose1(f, g):
        return lambda x: f(g(x))
```

We can understand the structure of a lambda expression by constructing a corresponding English sentence:

```
     lambda            x            :          f(g(x))
"A function that    takes x    and returns     f(g(x))"
```

The result of a lambda expression is called a lambda function. It has no intrinsic name (and so Python prints `<lambda>` for the name), but otherwise it behaves like any other function.

```py
>>> s = lambda x: x * x
>>> s
<function <lambda> at 0xf3f490>
>>> s(12)
144
```

In an environment diagram, the result of a lambda expression is a function as well, named with the greek letter λ (lambda). Our compose example can be expressed quite compactly with lambda expressions.

<iframe width="100%" height="550" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20compose1%28f,%20g%29%3A%0A%20%20%20%20return%20lambda%20x%3A%20f%28g%28x%29%29%0A%0Af%20%3D%20compose1%28lambda%20x%3A%20x%20*%20x,%0A%20%20%20%20%20%20%20%20%20%20%20%20%20lambda%20y%3A%20y%20%2B%201%29%0Aresult%20%3D%20f%2812%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

Some programmers find that using unnamed functions from lambda expressions to be shorter and more direct. However, compound lambda expressions are notoriously illegible, despite their brevity. The following definition is correct, but many programmers have trouble understanding it quickly.

```py
>>> compose1 = lambda f,g: lambda x: f(g(x))
```

In general, Python style prefers explicit def statements to lambda expressions, but allows them in cases where a simple function is needed as an argument or return value.

Such stylistic rules are merely guidelines; you can program any way you wish. However, as you write programs, think about the audience of people who might read your program one day. When you can make your program easier to understand, you do those people a favor.

The term lambda is a historical accident resulting from the incompatibility of written mathematical notation and the constraints of early type-setting systems.

> It may seem perverse to use lambda to introduce a procedure/function. The notation goes back to Alonzo Church, who in the 1930's started with a "hat" symbol; he wrote the square function as "ŷ . y × y". But frustrated typographers moved the hat to the left of the parameter and changed it to a capital lambda: "Λy . y × y"; from there the capital lambda was changed to lowercase, and now we see "λy . y × y" in math books and (lambda (y) (* y y)) in Lisp.
> 
> — Peter Norvig (norvig.com/lispy2.html)

Despite their unusual etymology, lambda expressions and the corresponding formal language for function application, the _lambda calculus_, are fundamental computer science concepts shared far beyond the Python programming community. We will revisit this topic when we study the design of interpreters in Chapter 3.

## 1.6.8 抽象和一等函数

We began this section with the observation that user-defined functions are a crucial abstraction mechanism, because they permit us to express general methods of computing as explicit elements in our programming language. Now we've seen how higher-order functions permit us to manipulate these general methods to create further abstractions.

As programmers, we should be alert to opportunities to identify the underlying abstractions in our programs, build upon them, and generalize them to create more powerful abstractions. This is not to say that one should always write programs in the most abstract way possible; expert programmers know how to choose the level of abstraction appropriate to their task. But it is important to be able to think in terms of these abstractions, so that we can be ready to apply them in new contexts. The significance of higher-order functions is that they enable us to represent these abstractions explicitly as elements in our programming language, so that they can be handled just like other computational elements.

In general, programming languages impose restrictions on the ways in which computational elements can be manipulated. Elements with the fewest restrictions are said to have first-class status. Some of the "rights and privileges" of first-class elements are:

1.  They may be bound to names.
2.  They may be passed as arguments to functions.
3.  They may be returned as the results of functions.
4.  They may be included in data structures.

Python awards functions full first-class status, and the resulting gain in expressive power is enormous.

## 1.6.9 函数装饰器

Python provides special syntax to apply higher-order functions as part of executing a def statement, called a decorator. Perhaps the most common example is a trace.

```py
>>> def trace(fn):
        def wrapped(x):
            print('-> ', fn, '(', x, ')')
            return fn(x)
        return wrapped
>>> @trace
    def triple(x):
        return 3 * x
>>> triple(12)
->  <function triple at 0x102a39848> ( 12 )
36
```

In this example, A higher-order function trace is defined, which returns a function that precedes a call to its argument with a print statement that outputs the argument. The def statement for triple has an annotation, @trace, which affects the execution rule for def. As usual, the function triple is created. However, the name triple is not bound to this function. Instead, the name triple is bound to the returned function value of calling trace on the newly defined triple function. In code, this decorator is equivalent to:

```py
>>> def triple(x):
        return 3 * x
>>> triple = trace(triple)
```

In the projects associated with this text, decorators are used for tracing, as well as selecting which functions to call when a program is run from the command line.

**Extra for experts.** The decorator symbol @ may also be followed by a call expression. The expression following @ is evaluated first (just as the name trace was evaluated above), the def statement second, and finally the result of evaluating the decorator expression is applied to the newly defined function, and the result is bound to the name in the def statement. A [short tutorial on decorators](http://programmingbits.pythonblogs.com/27_programmingbits/archive/50_function_decorators.html) by Ariel Ortiz gives further examples for interested students.