# 1.7 递归函数

:::info
译者：[Mancuoj](https://github.com/mancuoj)

协议：[CC BY-NC-SA 3.0](https://creativecommons.org/licenses/by-nc-sa/3.0/)

来源：[1.7 Recursive Functions](http://composingprograms.com/pages/17-recursive-functions.html)
:::

如果函数体中直接或间接调用函数本身，则函数称为递归（recursive）函数。也就是说，执行递归函数体的过程中可能要再次调用该函数。在 Python 中，递归函数不需要使用任何特殊语法，但它们确实需要一些努力来理解和创建。

我们将从一个样例开始：编写一个对自然数的所有数字位求和的函数。在设计递归函数时，我们需要找到可以将问题分解为更简单问题的方法。在这个示例中，可以使用运算符 `%` 和 `//` 将数字拆分成两部分：它的最后一位数字和除了最后一位以外的所有数字。

```py
>>> 18117 % 10
7
>>> 18117 // 10
1811
```

18117 的数字位之和是 $1+8+1+1+7 = 18$ 。正如同我们可以拆分数字一样，我们可以将这个和分成最后一位数字 7 和除最后一位数字之外所有数字的和 $1+8+1+1 = 11$ 。这种拆分为我们提供了一种算法：要对数字 n 的数字位求和，就将其最后一位数字 `n % 10` 与 `n // 10` 的所有数字位之和相加。其中有一种特殊情况：如果数字只有一位，那么它的数字位之和就是它本身。该算法可以使用递归函数来实现。

```py
>>> def sum_digits(n):
        """返回正整数 n 的所有数字位之和"""
        if n < 10:
            return n
        else:
            all_but_last, last = n // 10, n % 10
            return sum_digits(all_but_last) + last
```

这个 sum_digits 函数的定义是完整且正确的，尽管它在自己的主体内部调用了 sum_digits 函数。将数字位求和的问题分解为两个步骤：首先对除最后一位以外的所有数字求和，然后再将最后一位加上。这两个步骤都比原始问题简单。该函数是递归的，因为第一步是与原始问题相同类型的问题。也就是说，sum_digits 正是我们需要来实现 sum_digits 的函数。

```py
>>> sum_digits(9)
9
>>> sum_digits(18117)
18
>>> sum_digits(9437184)
36
>>> sum_digits(11408855402054064613470328848384)
126
```

我们可以通过计算环境模型来精确理解这个递归函数如何成功地应用，而不需要新的规则。

<iframe width="100%" height="600" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20sum_digits%28n%29%3A%0A%20%20%20%20if%20n%20%3C%2010%3A%0A%20%20%20%20%20%20%20%20return%20n%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20all_but_last,%20last%20%3D%20n%20//%2010,%20n%20%25%2010%0A%20%20%20%20%20%20%20%20return%20sum_digits%28all_but_last%29%20%2B%20last%0A%0Asum_digits%28738%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

当执行 `def` 语句时，名称 `sum_digits` 被绑定到一个新函数，但该函数的主体尚未执行。因此，`sum_digits` 的循环特性暂时还不是一个问题。然后，`sum_digits` 被传入参数 738：

1. 创建一个绑定到 `n` 值为 738 的局部帧，并在该帧作为起点的环境中执行 `sum_digits` 的主体。
2. 由于 738 不小于 10，执行了第 4 行的赋值语句，将 738 分为 73 和 8。
3. 在下面的返回语句中，对 `all_but_last` 的值 73 调用了 `sum_digits`，它是当前环境中的一个表达式。
4. 创建另一个绑定到 `n` 值为 73 的局部帧，再次在这个帧作为起点的环境中执行 `sum_digits` 的主体。
5. 由于 73 也不小于 10，将 73 分为 7 和 3，并对 `all_but_last` 的值 7 在此帧中进行求值并调用 `sum_digits`。
6. 创建第三个局部帧，绑定到 `n` 值为 7。
7. 在从这个帧开始的环境中，表达式 `n < 10` 为真，因此返回 7。
8. 在第二个局部帧中，将这个返回值 7 与 `last` 的值 3 相加，返回 10。
9. 在第一个局部帧中，将这个返回值 10 与 `last` 的值 8 相加，返回 18。

这个递归函数是正确应用的，尽管它是循环的，因为它被应用了两次，但每次使用不同的参数。此外，第二次应用比第一次更简单。生成调用 `sum_digits(18117)` 的环境图，就可以看到每次对 `sum_digits` 的调用都比上一次使用更小的参数，直到最终达到单个数字输入为止。

这个示例还说明了如何通过递归使用具有简单函数体的函数来演变出复杂的计算过程。


## 1.7.1 递归函数剖析

许多递归函数的函数体中都有一个共同的模式。函数体以一个*基础情况*开始，这是一个条件语句，定义了对最简单的输入处理的行为。在 `sum_digits` 的情况下，基本情况是任何单个数字的参数，我们只需返回该参数。一些递归函数将有多个基本情况。

然后，在基本情况之后，会有一个或多个递归调用。递归调用总是有一个特定的特点：它们简化了原始问题。递归函数通过逐步简化问题来表达计算。例如，对于7的数字求和比对73的数字求和更简单，对于738的数字求和更简单。对于每个后续调用，要完成的工作量都会减少。

递归函数通常以与我们先前使用的迭代方法不同的方式解决问题。考虑一个计算n的阶乘的函数 `fact`，其中例如 `fact(4)` 计算 $4!=4⋅3⋅2⋅1=244!=4⋅3⋅2⋅1=24$ 。

使用 `while` 语句的自我迭代函数通过将每个正整数乘到 `n` 上来累积总和。

```py
>>> def fact_iter(n):
        total, k = 1, 1
        while k <= n:
            total, k = total * k, k + 1
        return total

>>> fact_iter(4)
24
```

另一方面，阶乘的递归实现可以通过将 `fact(n-1)` 简单问题的结果表达为 `fact(n)`。递归的基本情况是问题的最简形式：`fact(1)` 是1。

These two factorial functions differ conceptually. The iterative function constructs the result from the base case of 1 to the final total by successively multiplying in each term. The recursive function, on the other hand, constructs the result directly from the final term, n, and the result of the simpler problem, fact(n-1).

As the recursion "unwinds" through successive applications of the _fact_ function to simpler and simpler problem instances, the result is eventually built starting from the base case. The recursion ends by passing the argument 1 to fact; the result of each call depends on the next until the base case is reached.

The correctness of this recursive function is easy to verify from the standard definition of the mathematical function for factorial:

$$
\begin{aligned}
(n-1) ! & =(n-1) \cdot(n-2) \cdots \cdots 1 \\
n ! & =n \cdot(n-1) \cdot(n-2) \cdots \cdots 1 \\
n ! & =n \cdot(n-1) !
\end{aligned}
$$

While we can unwind the recursion using our model of computation, it is often clearer to think about recursive calls as functional abstractions. That is, we should not care about how fact(n-1) is implemented in the body of fact; we should simply trust that it computes the factorial of n-1. Treating a recursive call as a functional abstraction has been called a _recursive leap of faith_. We define a function in terms of itself, but simply trust that the simpler cases will work correctly when verifying the correctness of the function. In this example, we trust that fact(n-1) will correctly compute (n-1)!; we must only check that n! is computed correctly if this assumption holds. In this way, verifying the correctness of a recursive function is a form of proof by induction.

The functions _fact_iter_ and _fact_ also differ because the former must introduce two additional names, total and k, that are not required in the recursive implementation. In general, iterative functions must maintain some local state that changes throughout the course of computation. At any point in the iteration, that state characterizes the result of completed work and the amount of work remaining. For example, when k is 3 and total is 2, there are still two terms remaining to be processed, 3 and 4. On the other hand, _fact_ is characterized by its single argument n. The state of the computation is entirely contained within the structure of the environment, which has return values that take the role of total, and binds n to different values in different frames rather than explicitly tracking k.

Recursive functions leverage the rules of evaluating call expressions to bind names to values, often avoiding the nuisance of correctly assigning local names during iteration. For this reason, recursive functions can be easier to define correctly. However, learning to recognize the computational processes evolved by recursive functions certainly requires practice.

## 1.7.2 相互递归

When a recursive procedure is divided among two functions that call each other, the functions are said to be _mutually recursive_. As an example, consider the following definition of even and odd for non-negative integers:

-   a number is even if it is one more than an odd number
-   a number is odd if it is one more than an even number
-   0 is even

Using this definition, we can implement mutually recursive functions to determine whether a number is even or odd:

<iframe width="100%" height="760" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20is_even%28n%29%3A%0A%20%20%20%20if%20n%20%3D%3D%200%3A%0A%20%20%20%20%20%20%20%20return%20True%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20is_odd%28n-1%29%0A%0Adef%20is_odd%28n%29%3A%0A%20%20%20%20if%20n%20%3D%3D%200%3A%0A%20%20%20%20%20%20%20%20return%20False%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20is_even%28n-1%29%0A%0Aresult%20%3D%20is_even%284%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

Mutually recursive functions can be turned into a single recursive function by breaking the abstraction boundary between the two functions. In this example, the body of is_odd can be incorporated into that of is_even, making sure to replace n with n-1 in the body of is_odd to reflect the argument passed into it:

```py
>>> def is_even(n):
        if n == 0:
            return True
        else:
            if (n-1) == 0:
                return False
            else:
                return is_even((n-1)-1)
```

As such, mutual recursion is no more mysterious or powerful than simple recursion, and it provides a mechanism for maintaining abstraction within a complicated recursive program.

## 1.7.3 递归函数中的打印

The computational process evolved by a recursive function can often be visualized using calls to print. As an example, we will implement a function cascade that prints all prefixes of a number from largest to smallest to largest.

```py
>>> def cascade(n):
        """Print a cascade of prefixes of n."""
        if n < 10:
            print(n)
        else:
            print(n)
            cascade(n//10)
            print(n)

>>> cascade(2013)
2013
201
20
2
20
201
2013
```

In this recursive function, the base case is a single-digit number, which is printed. Otherwise, a recursive call is placed between two calls to print.

It is not a rigid requirement that base cases be expressed before recursive calls. In fact, this function can be expressed more compactly by observing that print(n) is repeated in both clauses of the conditional statement, and therefore can precede it.

```py
>>> def cascade(n):
        """Print a cascade of prefixes of n."""
        print(n)
        if n >= 10:
            cascade(n//10)
            print(n)
```

As another example of mutual recursion, consider a two-player game in which there are n initial pebbles on a table. The players take turns, removing either one or two pebbles from the table, and the player who removes the final pebble wins. Suppose that Alice and Bob play this game, each using a simple strategy:

-   Alice always removes a single pebble
-   Bob removes two pebbles if an even number of pebbles is on the table, and one otherwise

Given n initial pebbles and Alice starting, who wins the game?

A natural decomposition of this problem is to encapsulate each strategy in its own function. This allows us to modify one strategy without affecting the other, maintaining the abstraction barrier between the two. In order to incorporate the turn-by-turn nature of the game, these two functions call each other at the end of each turn.

```py
>>> def play_alice(n):
        if n == 0:
            print("Bob wins!")
        else:
            play_bob(n-1)

>>> def play_bob(n):
        if n == 0:
            print("Alice wins!")
        elif is_even(n):
            play_alice(n-2)
        else:
            play_alice(n-1)

>>> play_alice(20)
Bob wins!
```

In play_bob, we see that multiple recursive calls may appear in the body of a function. However, in this example, each call to play_bob calls play_alice at most once. In the next section, we consider what happens when a single function call makes multiple direct recursive calls.

## 1.7.4 树递归

Another common pattern of computation is called tree recursion, in which a function calls itself more than once. As an example, consider computing the sequence of Fibonacci numbers, in which each number is the sum of the preceding two.

<iframe width="100%" height="600" frameborder="0" src="https://pythontutor.com/iframe-embed.html#code=def%20fib%28n%29%3A%0A%20%20%20%20if%20n%20%3D%3D%201%3A%0A%20%20%20%20%20%20%20%20return%200%0A%20%20%20%20if%20n%20%3D%3D%202%3A%0A%20%20%20%20%20%20%20%20return%201%0A%20%20%20%20else%3A%0A%20%20%20%20%20%20%20%20return%20fib%28n-2%29%20%2B%20fib%28n-1%29%0A%0Aresult%20%3D%20fib%286%29&codeDivHeight=400&codeDivWidth=350&cumulative=true&curInstr=0&origin=composingprograms.js&py=3&rawInputLstJSON=%5B%5D"> </iframe>

This recursive definition is tremendously appealing relative to our previous attempts: it exactly mirrors the familiar definition of Fibonacci numbers. A function with multiple recursive calls is said to be tree recursive because each call branches into multiple smaller calls, each of which branches into yet smaller calls, just as the branches of a tree become smaller but more numerous as they extend from the trunk.

We were already able to define a function to compute Fibonacci numbers without tree recursion. In fact, our previous attempts were more efficient, a topic discussed later in the text. Next, we consider a problem for which the tree recursive solution is substantially simpler than any iterative alternative.

## 1.7.5 示例：分区

The number of partitions of a positive integer n, using parts up to size m, is the number of ways in which n can be expressed as the sum of positive integer parts up to m in increasing order. For example, the number of partitions of 6 using parts up to 4 is 9.

```
1.  6 = 2 + 4
2.  6 = 1 + 1 + 4
3.  6 = 3 + 3
4.  6 = 1 + 2 + 3
5.  6 = 1 + 1 + 1 + 3
6.  6 = 2 + 2 + 2
7.  6 = 1 + 1 + 2 + 2
8.  6 = 1 + 1 + 1 + 1 + 2
9.  6 = 1 + 1 + 1 + 1 + 1 + 1
```

We will define a function count_partitions(n, m) that returns the number of different partitions of n using parts up to m. This function has a simple solution as a tree-recursive function, based on the following observation:

The number of ways to partition n using integers up to m equals

1.  the number of ways to partition n-m using integers up to m, and
2.  the number of ways to partition n using integers up to m-1.

To see why this is true, observe that all the ways of partitioning n can be divided into two groups: those that include at least one m and those that do not. Moreover, each partition in the first group is a partition of n-m, followed by m added at the end. In the example above, the first two partitions contain 4, and the rest do not.

Therefore, we can recursively reduce the problem of partitioning n using integers up to m into two simpler problems: (1) partition a smaller number n-m, and (2) partition with smaller components up to m-1.

To complete the implementation, we need to specify the following base cases:

1.  There is one way to partition 0: include no parts.
2.  There are 0 ways to partition a negative n.
3.  There are 0 ways to partition any n greater than 0 using parts of size 0 or less.

```py
>>> def count_partitions(n, m):
        """Count the ways to partition n using parts up to m."""
        if n == 0:
            return 1
        elif n < 0:
            return 0
        elif m == 0:
            return 0
        else:
            return count_partitions(n-m, m) + count_partitions(n, m-1)

>>> count_partitions(6, 4)
9
>>> count_partitions(5, 5)
7
>>> count_partitions(10, 10)
42
>>> count_partitions(15, 15)
176
>>> count_partitions(20, 20)
627
```

We can think of a tree-recursive function as exploring different possibilities. In this case, we explore the possibility that we use a part of size m and the possibility that we do not. The first and second recursive calls correspond to these possibilities.

Implementing this function without recursion would be substantially more involved. Interested readers are encouraged to try.