# 1.2 编程要素

A programming language is more than just a means for instructing a computer to perform tasks. The language also serves as a framework within which we organize our ideas about computational processes. Programs serve to communicate those ideas among the members of a programming community. Thus, programs must be written for people to read, and only incidentally for machines to execute.

编程语言不仅仅是一种指示计算机执行任务的方法 执行任务。 该语言还充当我们组织的框架 我们关于计算过程的想法。 程序用于传达那些 编程社区成员之间的想法。 因此，程序必须是 写给人们阅读，只是为了让机器执行。


When we describe a language, we should pay particular attention to the means that the language provides for combining simple ideas to form more complex ideas. Every powerful language has three such mechanisms:

当我们描述一种语言时，我们应该特别注意手段 该语言提供了将简单的想法组合起来形成更复杂的 想法。 每一种强大的语言都有三种这样的机制：

- primitive expressions and statements, which represent the simplest building blocks that the language provides,
- ==原始表达式和语句==，代表最简单的 语言提供的构建块，
- means of combination, by which compound elements are built from simpler ones, and
- ==组合的方法==，复合元素由简单的元素构成 一个，和
- means of abstraction, by which compound elements can be named and manipulated as units.
- ==抽象的手段==，通过它可以命名和组合元素 作为单位进行操作。

In programming, we deal with two kinds of elements: functions and data. (Soon we will discover that they are really not so distinct.) Informally, data is stuff that we want to manipulate, and functions describe the rules for manipulating the data. Thus, any powerful programming language should be able to describe primitive data and primitive functions, as well as have some methods for combining and abstracting both functions and data.

在编程中，我们处理两种元素：函数和数据。 （很快 我们会发现它们实际上并没有那么明显。）非正式地，数据是 我们想要操作的东西，函数描述了规则 操纵数据。 因此，任何强大的编程语言都应该 能够描述原始数据和原始函数，并具有一定的 结合和抽象函数和数据的方法。

## 1.2.1 表达式

Having experimented with the full Python interpreter in the previous section, we now start anew, methodically developing the Python language element by element. Be patient if the examples seem simplistic — more exciting material is soon to come.

在上一节中尝试了完整的 Python 解释器后， 我们现在重新开始，有条不紊地开发 Python 语言元素 元素。 如果示例看起来过于简单，请耐心等待——更令人兴奋的材料 即将到来。

We begin with primitive expressions. One kind of primitive expression is a number. More precisely, the expression that you type consists of the numerals that represent the number in base 10.

我们从原始表达式开始。 一种原始表达式是 数字。 更准确地说，您键入的表达式由数字组成 代表以 10 为基数的数字。

```py
>>> 42
42
```

Expressions representing numbers may be combined with mathematical operators to form a compound expression, which the interpreter will evaluate:

表示数字的表达式可以与数学运算符组合 形成一个复合表达式，解释器将对其进行评估：

```py
>>> -1 - -1
0
>>> 1/2 + 1/4 + 1/8 + 1/16 + 1/32 + 1/64 + 1/128
0.9921875
```

These mathematical expressions use infix notation, where the operator (e.g., +, -, *, or /) appears in between the operands (numbers). Python includes many ways to form compound expressions. Rather than attempt to enumerate them all immediately, we will introduce new expression forms as we go, along with the language features that they support.

这些数学表达式使用 中缀 表示法，其中 运算符 （例如 + 、 - 、 * 或 / ）出现在 操作数 之间 （数字）。 Python 包含许多形成复合表达式的方法。 而不是 尝试立即枚举它们，我们将引入新的表达式 形式，以及它们支持的语言功能。

## 1.2.2 调用表达式

The most important kind of compound expression is a call expression, which applies a function to some arguments. Recall from algebra that the mathematical notion of a function is a mapping from some input arguments to an output value. For instance, the max function maps its inputs to a single output, which is the largest of the inputs. The way in which Python expresses function application is the same as in conventional mathematics.

最重要的一种复合表达式是 调用表达式 ，它 将函数应用于某些参数。 回想一下代数中的数学 函数的概念是从一些输入参数到输出值的映射。 例如， max 函数将其输入映射到单个输出，即 最大的输入。 Python表达函数的方式 应用与传统数学相同。

```py
>>> max(7.5, 9.5)
9.5
```

This call expression has subexpressions: the operator is an expression that precedes parentheses, which enclose a comma-delimited list of operand expressions.

这个调用表达式有子表达式： 运算符 是一个表达式 在括号之前，其中包含一个以逗号分隔的 操作数 列表 表达式。

![call_expression](/sicp-python/call_expression.png)

The operator specifies a function. When this call expression is evaluated, we say that the function max is called with arguments 7.5 and 9.5, and returns a value of 9.5.

运算符指定一个 函数 。 评估此调用表达式时， 我们说函数 max 是 调用 用 参数 7.5 和 9.5 的，并且 返回 值 9.5 。

The order of the arguments in a call expression matters. For instance, the function pow raises its first argument to the power of its second argument.

调用表达式中参数的顺序很重要。 例如， 函数 pow 将它的第一个参数提高到它的第二个参数的幂。

```py
>>> pow(100, 2)
10000
>>> pow(2, 100)
1267650600228229401496703205376
```

Function notation has three principal advantages over the mathematical convention of infix notation. First, functions may take an arbitrary number of arguments:

函数符号与数学符号相比具有三个主要优点 中缀符号的约定。 首先，函数可以采用任意数量的 参数：

```py
>>> max(1, -2, 3, -4)
3
```

No ambiguity can arise, because the function name always precedes its arguments.

不会出现歧义，因为函数名总是在它的前面 争论。

Second, function notation extends in a straightforward way to nested expressions, where the elements are themselves compound expressions. In nested call expressions, unlike compound infix expressions, the structure of the nesting is entirely explicit in the parentheses.

其次，函数符号以直接的方式扩展到 嵌套 表达式，其中元素本身是复合表达式。 在嵌套 与复合中缀表达式不同，调用表达式的结构 嵌套在括号中是完全明确的。

```py
>>> max(min(1, -2), min(pow(3, 5), -4))
-2
```

There is no limit (in principle) to the depth of such nesting and to the overall complexity of the expressions that the Python interpreter can evaluate. However, humans quickly get confused by multi-level nesting. An important role for you as a programmer is to structure expressions so that they remain interpretable by yourself, your programming partners, and other people who may read your expressions in the future.

这种嵌套的深度和整体没有限制（原则上） Python 解释器可以评估的表达式的复杂性。 然而，人类很快就会对多层嵌套感到困惑。 重要作用 作为程序员，对你来说就是构造表达式，使它们保持不变 可由您自己、您的编程合作伙伴和其他可能的人解释 以后看你的表情。

Third, mathematical notation has a great variety of forms: multiplication appears between terms, exponents appear as superscripts, division as a horizontal bar, and a square root as a roof with slanted siding. Some of this notation is very hard to type! However, all of this complexity can be unified via the notation of call expressions. While Python supports common mathematical operators using infix notation (like + and -), any operator can be expressed as a function with a name.

三、数学符号形式多样：乘法 出现在项之间，指数显示为上标，除法显示为 单杠和平方根作为带有倾斜壁板的屋顶。 其中一些 符号很难输入！ 然而，所有这些复杂性都可以统一 通过调用表达式的符号。 虽然 Python 支持常见的数学 使用中缀符号的运算符（如 + 和 - ），任何运算符都可以 表示为具有名称的函数。

## 1.2.3 导入库函数

Python defines a very large number of functions, including the operator functions mentioned in the preceding section, but does not make all of their names available by default. Instead, it organizes the functions and other quantities that it knows about into modules, which together comprise the Python Library. To use these elements, one imports them. For example, the math module provides a variety of familiar mathematical functions:

Python 定义了大量的函数，包括运算符 上一节中提到的功能，但并没有使他们的所有 默认情况下可用的名称。 相反，它组织功能和其他 将它知道的数量放入模块中，这些模块共同构成了 Python 图书馆。 要使用这些元素，需要导入它们。 例如， 数学 模块提供了各种熟悉的数学函数：

```py
>>> from math import sqrt
>>> sqrt(256)
16.0
```

and the operator module provides access to functions corresponding to infix operators:

访问 operator 模块提供中缀对应的函数 运营商：

```py
>>> from operator import add, sub, mul
>>> add(14, 28)
42
>>> sub(100, mul(7, add(8, 4)))
16
```

An import statement designates a module name (e.g., operator or math), and then lists the named attributes of that module to import (e.g., sqrt). Once a function is imported, it can be called multiple times.

运算 导入 语句指定模块名称（例如， 符 或 math ），然后列出要导入的模块的命名属性（例如， 开方 ）。 一旦一个函数被导入，它就可以被多次调用。

There is no difference between using these operator functions (e.g., add) and the operator symbols themselves (e.g., +). Conventionally, most programmers use symbols and infix notation to express simple arithmetic.

之间没有区别 使用这些运算符函数（例如， add ） 和运算符符号本身（例如 + ）。 按照惯例，大多数 程序员使用符号和中缀表示法来表达简单的算术。

The [Python 3 Library Docs](http://docs.python.org/py3k/library/index.html) list the functions defined by each module, such as the [math module](http://docs.python.org/py3k/library/math.html). However, this documentation is written for developers who know the whole language well. For now, you may find that experimenting with a function tells you more about its behavior than reading the documentation. As you become familiar with the Python language and vocabulary, this documentation will become a valuable reference source.

列出了每个模块定义的 [Python 3 Library Docs](http://docs.python.org/py3k/library/index.html) 函数，例如 数学 [模块](http://docs.python.org/py3k/library/math.html) 。 但是，本文档是为开发人员编写的 熟悉整个语言。 现在，您可能会发现尝试使用 函数告诉你更多关于它的行为而不是阅读文档。 作为 您熟悉 Python 语言和词汇，本文档 将成为宝贵的参考资料。

## 1.2.4 名称与环境

A critical aspect of a programming language is the means it provides for using names to refer to computational objects. If a value has been given a name, we say that the name binds to the value.

编程语言的一个关键方面是它提供的使用方法 引用计算对象的名称。 如果一个值被赋予了名称，我们 说名称 绑定 到值。

In Python, we can establish new bindings using the assignment statement, which contains a name to the left of = and a value to the right:

在 Python 中，我们可以使用赋值语句建立新的绑定，这 的左边包含一个名称，在右边包含 在= 一个值：

```py
>>> radius = 10
>>> radius
10
>>> 2 * radius
20
```

Names are also bound via import statements.

名称也通过 import 语句绑定。

```py
>>> from math import pi
>>> pi * 71 / 223
1.0002380197528042
```

The = symbol is called the assignment operator in Python (and many other languages). Assignment is our simplest means of abstraction, for it allows us to use simple names to refer to the results of compound operations, such as the area computed above. In this way, complex programs are constructed by building, step by step, computational objects of increasing complexity.

赋值 = 符号在 Python 中称为 其他 运算符（以及许多 语言）。 赋值是我们最简单的 抽象 方法，因为它允许我们 使用简单名称来指代复合操作的结果，例如 上面计算的面积 。 以这种方式，复杂的程序由 逐步构建越来越复杂的计算对象。

The possibility of binding names to values and later retrieving those values by name means that the interpreter must maintain some sort of memory that keeps track of the names, values, and bindings. This memory is called an environment.

将名称绑定到值并稍后通过以下方式检索这些值的可能性 名称意味着解释器必须保持某种记忆 跟踪名称、值和绑定。 这段记忆被称为 环境 。

Names can also be bound to functions. For instance, the name max is bound to the max function we have been using. Functions, unlike numbers, are tricky to render as text, so Python prints an identifying description instead, when asked to describe a function:

名称也可以绑定到函数。 例如，名称 max 被绑定 到我们一直使用的 max 函数。 与数字不同，函数很难 呈现为文本，因此当被询问时，Python 会打印一个标识描述 描述一个函数：

```py
>>> max
<built-in function max>
```

We can use assignment statements to give new names to existing functions.

我们可以使用赋值语句为现有函数赋予新名称。

```py
>>> f = max
>>> f
<built-in function max>
>>> f(2, 3, 4)
4
```

And successive assignment statements can rebind a name to a new value.


连续的赋值语句可以将名称重新绑定到新值。

```py
>>> f = 2
>>> f
2
```

In Python, names are often called variable names or variables because they can be bound to different values in the course of executing a program. When a name is bound to a new value through assignment, it is no longer bound to any previous value. One can even bind built-in names to new values.


在 Python 中，名称通常被称为 变量名 或 变量 ，因为它们 可以在执行程序的过程中绑定到不同的值。 当一个 name 通过赋值绑定到一个新值，它不再绑定到任何 以前的价值。 甚至可以将内置名称绑定到新值。

```py
>>> max = 5
>>> max
5
```

After assigning max to 5, the name max is no longer bound to a function, and so attempting to call max(2, 3, 4) will cause an error.

将 max 赋值为5后，名称 max 不再绑定a 函数，因此尝试调用 max(2, 3, 4) 将导致错误。

When executing an assignment statement, Python evaluates the expression to the right of = before changing the binding to the name on the left. Therefore, one can refer to a name in right-side expression, even if it is the name to be bound by the assignment statement.

执行赋值语句时，Python 将表达式计算为 的右侧， = 然后将绑定更改为左侧的名称。 所以， 一个人可以在右侧表达式中引用一个名字，即使它是要成为的名字 受赋值语句约束。

```py
>>> x = 2
>>> x = x + 1
>>> x
3
```

We can also assign multiple values to multiple names in a single statement, where names on the left of = and expressions on the right of = are separated by commas.

我们还可以在单​​个语句中为多个名称分配多个值， 左边的名称和 = 右边的表达式 其中= 是 被逗号隔开。

```py
>>> area, circumference = pi * radius * radius, 2 * pi * radius
>>> area
314.1592653589793
>>> circumference
62.83185307179586
```

Changing the value of one name does not affect other names. Below, even though the name area was bound to a value defined originally in terms of radius, the value of area has not changed. Updating the value of area requires another assignment statement.

更改一个名称的值不会影响其他名称。 下面，虽然 名称 区域 绑定到最初定义的值 radius ， area 的值没有改变。 更新值 area 需要另一个赋值语句。

```py
>>> radius = 11
>>> area
314.1592653589793
>>> area = pi * radius * radius
380.132711084365
```

With multiple assignment, all expressions to the right of = are evaluated before any names to the left are bound to those values. As a result of this rule, swapping the values bound to two names can be performed in a single statement.

对于多重赋值， 所有 右边的 = 表达式都会被求值 在 左侧的任何 名称绑定到这些值之前。 由于这个 规则，交换绑定到两个名称的值可以在单个 陈述。

```py
>>> x, y = 3, 4.5
>>> y, x = x, y
>>> x
4.5
>>> y
3
```

## 1.2.5 求解嵌套表达式

One of our goals in this chapter is to isolate issues about thinking procedurally. As a case in point, let us consider that, in evaluating nested call expressions, the interpreter is itself following a procedure.

我们在本章中的目标之一是分离关于思维的问题 程序上。 作为一个恰当的例子，让我们考虑一下，在评估嵌套 call 表达式，解释器本身遵循一个过程。

To evaluate a call expression, Python will do the following:

为了评估调用表达式，Python 将执行以下操作：

Evaluate the operator and operand subexpressions, then
Apply the function that is the value of the operator subexpression to the arguments that are the values of the operand subexpressions.

评估运算符和操作数子表达式，然后将作为运算符子表达式值的函数应用于 作为操作数子表达式值的参数。

Even this simple procedure illustrates some important points about processes in general. The first step dictates that in order to accomplish the evaluation process for a call expression we must first evaluate other expressions. Thus, the evaluation procedure is recursive in nature; that is, it includes, as one of its steps, the need to invoke the rule itself.

即使是这个简单的程序也说明了有关流程的一些要点 一般的。 第一步规定，为了完成评估 对于调用表达式的处理，我们必须首先评估其他表达式。 因此， 评估程序本质上是 递归 的； 也就是说，它包括，作为一个 在其步骤中，需要调用规则本身。

For example, evaluating

例如，评估

```py
>>> sub(pow(2, add(1, 10)), pow(2, 5))
2016
```

requires that this evaluation procedure be applied four times. If we draw each expression that we evaluate, we can visualize the hierarchical structure of this process.

要求将此评估程序应用四次。 如果我们画出每一个 我们评估的表达式，我们可以想象这个的层次结构 过程。

![expression_tree](/sicp-python/expression_tree.png)

This illustration is called an _expression tree_. In computer science, trees conventionally grow from the top down. The objects at each point in a tree are called nodes; in this case, they are expressions paired with their values.

此图称为 _表达式树_ 。 在计算机科学中，树 通常从上到下增长。 树中每个点的对象是 称为节点； 在这种情况下，它们是与其值配对的表达式。

Evaluating its root, the full expression at the top, requires first evaluating the branches that are its subexpressions. The leaf expressions (that is, nodes with no branches stemming from them) represent either functions or numbers. The interior nodes have two parts: the call expression to which our evaluation rule is applied, and the result of that expression. Viewing evaluation in terms of this tree, we can imagine that the values of the operands percolate upward, starting from the terminal nodes and then combining at higher and higher levels.

评估其根，即顶部的完整表达式，需要首先评估 作为其子表达式的分支。 叶表达式（即节点 没有源自它们的分支）代表函数或数字。 这 内部节点有两部分：我们的评估规则所针对的调用表达式 被应用，以及该表达式的结果。 从以下方面查看评估 这棵树，我们可以想象操作数的值向上渗透， 从终端节点开始，然后越来越高地合并 水平。

Next, observe that the repeated application of the first step brings us to the point where we need to evaluate, not call expressions, but primitive expressions such as numerals (e.g., 2) and names (e.g., add). We take care of the primitive cases by stipulating that

接下来，观察第一步的重复应用将我们带到 我们需要评估的点，不是调用表达式，而是原始表达式 例如数字（例如 2）和名称（例如 add ）。 我们照顾 通过规定原始情况

-   A numeral evaluates to the number it names,
-   一个数字计算它命名的数字，
-   A name evaluates to the value associated with that name in the current environment.
-   一个名称的计算结果为与当前名称相关联的值 环境。

Notice the important role of an environment in determining the meaning of the symbols in expressions. In Python, it is meaningless to speak of the value of an expression such as

注意环境在决定意义的重要作用 表达式中的符号。 在 Python 中，谈论一个值是没有意义的 表达如

```py
>>> add(x, 1)
```

without specifying any information about the environment that would provide a meaning for the name x (or even for the name add). Environments provide the context in which evaluation takes place, which plays an important role in our understanding of program execution.

无需指定有关环境的任何信息 的含义 名称x （甚至名称 add 的含义）。 环境提供 评估发生的背景，这在评估中起着重要作用 我们对程序执行的理解。

This evaluation procedure does not suffice to evaluate all Python code, only call expressions, numerals, and names. For instance, it does not handle assignment statements. Executing

此评估程序不足以评估所有 Python 代码，仅 call 表达式、数字和名称。 例如，它不处理 赋值语句。 执行中

```py
>>> x = 3
```

does not return a value nor evaluate a function on some arguments, since the purpose of assignment is instead to bind a name to a value. In general, statements are not evaluated but _executed_; they do not produce a value but instead make some change. Each type of expression or statement has its own evaluation or execution procedure.

不返回值，也不对某些参数求值函数，因为 赋值的目的是将名称绑定到值。 一般来说， 语句不被评估但 _被执行_ ； 它们不产生价值，但 而是做出一些改变。 每种类型的表达式或语句都有自己的 评估或执行程序。

A pedantic note: when we say that "a numeral evaluates to a number," we actually mean that the Python interpreter evaluates a numeral to a number. It is the interpreter which endows meaning to the programming language. Given that the interpreter is a fixed program that always behaves consistently, we can say that numerals (and expressions) themselves evaluate to values in the context of Python programs.

一个迂腐的注释：当我们说“一个数字计算为一个数字”时，我们实际上 意味着 Python 解释器将数字计算为数字。 它是 赋予编程语言意义的解释器。 鉴于 解释器是一个固定的程序，它的行为总是一致的，我们可以说 数字（和表达式）本身在上下文中评估为值 Python 程序。

## 1.2.6 非纯函数 Print

Throughout this text, we will distinguish between two types of functions.

在本文中，我们将区分两种类型的函数。

**Pure functions.** Functions have some input (their arguments) and return some output (the result of applying them). The built-in function

**纯函数。** 函数有一些输入（它们的参数）并返回一些 输出（应用它们的结果）。 内置函数

```py
>>> abs(-2)
2
```

can be depicted as a small machine that takes input and produces output.

可以将其描述为接受输入并产生输出的小型机器。

![function_abs](/sicp-python/function_abs.png)

The function abs is _pure_. Pure functions have the property that applying them has no effects beyond returning a value. Moreover, a pure function must always return the same value when called twice with the same arguments.

函数 abs 是 _纯_ 的。 纯函数具有应用的属性 它们除了返回值外没有任何影响。 此外，纯函数必须 当使用相同的参数调用两次时总是返回相同的值。

**Non-pure functions.** In addition to returning a value, applying a non-pure function can generate _side effects_, which make some change to the state of the interpreter or computer. A common side effect is to generate additional output beyond the return value, using the print function.

**非纯函数。** 除了返回一个值，应用一个非纯 函数可以产生 _副作用_ ，这会对 口译员或计算机。 一个常见的副作用是产生额外的输出 超出返回值，使用 打印 函数。

```py
>>> print(1, 2, 3)
1 2 3
```

While print and abs may appear to be similar in these examples, they work in fundamentally different ways. The value that print returns is always None, a special Python value that represents nothing. The interactive Python interpreter does not automatically print the value None. In the case of print, the function itself is printing output as a side effect of being called.

虽然 print 和 abs 在这些例子中看起来很相似，但它们 以根本不同的方式工作。 的值 打印 返回 是 总是 None ，一个不代表任何东西的特殊 Python 值。 这 交互式 Python 解释器不会自动打印值 None 。 在 print 的情况下，函数本身是打印输出作为一面 被调用的效果。

![function_print](/sicp-python/function_print.png)

A nested expression of calls to print highlights the non-pure character of the function.

调用的嵌套表达式 打印 突出了非纯字符 功能。

```py
>>> print(print(1), print(2))
1
2
None None
```

If you find this output to be unexpected, draw an expression tree to clarify why evaluating this expression produces this peculiar output.

如果您发现此输出出乎意料，请绘制表达式树以阐明原因 评估这个表达式会产生这个特殊的输出。

Be careful with print! The fact that it returns None means that it _should not_ be the expression in an assignment statement.

小心 打印 ！ 的事实 它返回None 意味着它 _不应该_ 是赋值语句中的表达式。

```py
>>> two = print(2)
2
>>> print(two)
None
```

Pure functions are restricted in that they cannot have side effects or change behavior over time. Imposing these restrictions yields substantial benefits. First, pure functions can be composed more reliably into compound call expressions. We can see in the non-pure function example above that print does not return a useful result when used in an operand expression. On the other hand, we have seen that functions such as max, pow and sqrt can be used effectively in nested expressions.

纯函数受到限制，因为它们不能有副作用或改变 随着时间的推移行为。 施加这些限制会产生巨大的好处。 首先，纯函数可以更可靠地组合成复合调用 表达式。 我们可以在上面的非纯函数示例中看到 打印 在操作数表达式中使用时不会返回有用的结果。 在 另一方面，我们已经看到 max 、 pow 和 sqrt 等函数 可以在嵌套表达式中有效使用。

Second, pure functions tend to be simpler to test. A list of arguments will always lead to the same return value, which can be compared to the expected return value. Testing is discussed in more detail later in this chapter.

其次，纯函数往往更易于测试。 参数列表将 总是导致相同的返回值，这可以与预期进行比较 返回值。 本章稍后将更详细地讨论测试。

Third, Chapter 4 will illustrate that pure functions are essential for writing _concurrent_ programs, in which multiple call expressions may be evaluated simultaneously.

第三，第4章将说明纯函数对于写作来说是必不可少的 _并发_ 程序，其中可以评估多个调用表达式 同时。

By contrast, Chapter 2 investigates a range of non-pure functions and describes their uses.

相比之下，第 2 章研究了一系列非纯函数并描述了 他们的用途。

For these reasons, we concentrate heavily on creating and using pure functions in the remainder of this chapter. The print function is only used so that we can see the intermediate results of computations.

由于这些原因，我们非常专注于创建和使用纯函数 在本章的其余部分。 打印 功能 仅用于 我们可以看到计算的中间结果。